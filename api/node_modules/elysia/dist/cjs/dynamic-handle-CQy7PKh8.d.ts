import { WebSocketHandler, Server, Serve, ServerWebSocket } from 'bun';
import { Memoirist } from 'memoirist';
import * as _sinclair_typebox from '@sinclair/typebox';
import { TSchema, Static, TAnySchema, TObject, NumberOptions, SchemaOptions, TNumber, DateOptions, TDate, TBoolean, TProperties, ObjectOptions, TUnion, TNull, TUndefined } from '@sinclair/typebox';
import { TypeCheck } from '@sinclair/typebox/compiler';
import { OpenAPIV3 } from 'openapi-types';
import { EventEmitter } from 'eventemitter3';
import { ELYSIA_RESPONSE, ValidationError, NotFoundError, ParseError, InternalServerError, InvalidCookieSignature, error, ElysiaErrors } from './error.js';
import '@sinclair/typebox/system';
import * as undici_types from 'undici-types';

interface CookieOptions {
    /**
     * Specifies the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.3|Domain Set-Cookie attribute}. By default, no
     * domain is set, and most clients will consider the cookie to apply to only
     * the current domain.
     */
    domain?: string | undefined;
    /**
     * Specifies the `Date` object to be the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.1|`Expires` `Set-Cookie` attribute}. By default,
     * no expiration is set, and most clients will consider this a "non-persistent cookie" and will delete
     * it on a condition like exiting a web browser application.
     *
     * *Note* the {@link https://tools.ietf.org/html/rfc6265#section-5.3|cookie storage model specification}
     * states that if both `expires` and `maxAge` are set, then `maxAge` takes precedence, but it is
     * possible not all clients by obey this, so if both are set, they should
     * point to the same date and time.
     */
    expires?: Date | undefined;
    /**
     * Specifies the boolean value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.6|`HttpOnly` `Set-Cookie` attribute}.
     * When truthy, the `HttpOnly` attribute is set, otherwise it is not. By
     * default, the `HttpOnly` attribute is not set.
     *
     * *Note* be careful when setting this to true, as compliant clients will
     * not allow client-side JavaScript to see the cookie in `document.cookie`.
     */
    httpOnly?: boolean | undefined;
    /**
     * Specifies the number (in seconds) to be the value for the `Max-Age`
     * `Set-Cookie` attribute. The given number will be converted to an integer
     * by rounding down. By default, no maximum age is set.
     *
     * *Note* the {@link https://tools.ietf.org/html/rfc6265#section-5.3|cookie storage model specification}
     * states that if both `expires` and `maxAge` are set, then `maxAge` takes precedence, but it is
     * possible not all clients by obey this, so if both are set, they should
     * point to the same date and time.
     */
    maxAge?: number | undefined;
    /**
     * Specifies the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.4|`Path` `Set-Cookie` attribute}.
     * By default, the path is considered the "default path".
     */
    path?: string | undefined;
    /**
     * Specifies the `string` to be the value for the [`Priority` `Set-Cookie` attribute][rfc-west-cookie-priority-00-4.1].
     *
     * - `'low'` will set the `Priority` attribute to `Low`.
     * - `'medium'` will set the `Priority` attribute to `Medium`, the default priority when not set.
     * - `'high'` will set the `Priority` attribute to `High`.
     *
     * More information about the different priority levels can be found in
     * [the specification][rfc-west-cookie-priority-00-4.1].
     *
     * **note** This is an attribute that has not yet been fully standardized, and may change in the future.
     * This also means many clients may ignore this attribute until they understand it.
     */
    priority?: 'low' | 'medium' | 'high' | undefined;
    /**
     * Specifies the boolean or string to be the value for the {@link https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-4.1.2.7|`SameSite` `Set-Cookie` attribute}.
     *
     * - `true` will set the `SameSite` attribute to `Strict` for strict same
     * site enforcement.
     * - `false` will not set the `SameSite` attribute.
     * - `'lax'` will set the `SameSite` attribute to Lax for lax same site
     * enforcement.
     * - `'strict'` will set the `SameSite` attribute to Strict for strict same
     * site enforcement.
     *  - `'none'` will set the SameSite attribute to None for an explicit
     *  cross-site cookie.
     *
     * More information about the different enforcement levels can be found in {@link https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-4.1.2.7|the specification}.
     *
     * *note* This is an attribute that has not yet been fully standardized, and may change in the future. This also means many clients may ignore this attribute until they understand it.
     */
    sameSite?: true | false | 'lax' | 'strict' | 'none' | undefined;
    /**
     * Specifies the boolean value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.5|`Secure` `Set-Cookie` attribute}. When truthy, the
     * `Secure` attribute is set, otherwise it is not. By default, the `Secure` attribute is not set.
     *
     * *Note* be careful when setting this to `true`, as compliant clients will
     * not send the cookie back to the server in the future if the browser does
     * not have an HTTPS connection.
     */
    secure?: boolean | undefined;
    /**
     * Secret key for signing cookie
     *
     * If array is passed, will use Key Rotation.
     *
     * Key rotation is when an encryption key is retired
     * and replaced by generating a new cryptographic key.
     */
    secrets?: string | string[];
}
type ElysiaCookie = Prettify<CookieOptions & {
    value?: unknown;
}>;
type Updater<T> = T | ((value: T) => T);
declare class Cookie<T> implements ElysiaCookie {
    private name;
    private jar;
    private initial;
    constructor(name: string, jar: Record<string, ElysiaCookie>, initial?: Partial<ElysiaCookie>);
    get cookie(): ElysiaCookie;
    set cookie(jar: ElysiaCookie);
    get value(): T;
    set value(value: T);
    get expires(): Date | undefined;
    set expires(expires: Date | undefined);
    get maxAge(): number | undefined;
    set maxAge(maxAge: number | undefined);
    get domain(): string | undefined;
    set domain(domain: string | undefined);
    get path(): string | undefined;
    set path(path: string | undefined);
    get secure(): boolean | undefined;
    set secure(secure: boolean | undefined);
    get httpOnly(): boolean | undefined;
    set httpOnly(httpOnly: boolean | undefined);
    get sameSite(): boolean | "lax" | "strict" | "none" | undefined;
    set sameSite(sameSite: boolean | "lax" | "strict" | "none" | undefined);
    get priority(): "low" | "medium" | "high" | undefined;
    set priority(priority: "low" | "medium" | "high" | undefined);
    get secrets(): string | string[] | undefined;
    set secrets(secrets: string | string[] | undefined);
    update(config: Updater<Partial<ElysiaCookie>>): this;
    set(config: Updater<Partial<ElysiaCookie>>): this;
    remove(): this | undefined;
    toString(): string;
}
declare const createCookieJar: (set: Context['set'], store: Record<string, ElysiaCookie>, initial?: Partial<ElysiaCookie>) => Record<string, Cookie<unknown>>;
declare const parseCookie: (set: Context['set'], cookieString?: string | null, { secret, sign, ...initial }?: CookieOptions & {
    secret?: string | string[] | undefined;
    sign?: string | true | string[] | undefined;
}) => Promise<Record<string, Cookie<unknown>>>;

type PartialServe = Partial<Serve>;
type ElysiaConfig<Prefix extends string | undefined, Scoped extends boolean | undefined> = {
    prefix?: Prefix;
    scoped?: Scoped;
    name?: string;
    seed?: unknown;
    serve?: PartialServe;
    /**
     * Warm up Elysia before starting the server
     *
     * This will perform Ahead of Time compilation and generate code for route handlers
     *
     * If set to false, Elysia will perform Just in Time compilation
     *
     * Only required for root instance (instance which use listen) to effect
     *
     * ! If performing a benchmark, it's recommended to set this to `true`
     *
     * @default false
     */
    precompile?: boolean | {
        /**
         * Perform dynamic code generation for route handlers before starting the server
         *
         * @default false
         */
        compose?: boolean;
        /**
         * Perform Ahead of Time compilation for schema before starting the server
         *
         * @default false
         */
        schema?: boolean;
    };
    /**
     * Disable `new Error` thrown marked as Error on Bun 0.6
     */
    forceErrorEncapsulation?: boolean;
    /**
     * Disable sucrose dynamic query inference
     */
    forceDynamicQuery?: boolean;
    /**
     * Disable Ahead of Time compliation
     *
     * Reduced performance but faster startup time
     */
    aot?: boolean;
    /**
     * Whether should Elysia tolerate suffix '/' or vice-versa
     *
     * @default false
     */
    strictPath?: boolean;
    /**
     * If set to true, other Elysia handler will not inherits global life-cycle, store, decorators from the current instance
     *
     * @default false
     */
    websocket?: Omit<WebSocketHandler<any>, 'open' | 'close' | 'message' | 'drain'>;
    cookie?: CookieOptions & {
        /**
         * Specified cookie name to be signed globally
         */
        sign?: true | string | string[];
    };
    /**
     * Capture more detail information for each dependencies
     */
    analytic?: boolean;
    /**
     * Enable experimental features
     */
    experimental?: {};
};
type MaybeArray<T> = T | T[];
type MaybePromise<T> = T | Promise<T>;
type ObjectValues<T extends object> = T[keyof T];
type IsPathParameter<Part extends string> = Part extends `:${infer Parameter}` ? Parameter : Part extends `*` ? '*' : never;
type GetPathParameter<Path extends string> = Path extends `${infer A}/${infer B}` ? IsPathParameter<A> | GetPathParameter<B> : IsPathParameter<Path>;
type Prettify<T> = {
    [K in keyof T]: T[K];
} & {};
type Prettify2<T> = {
    [K in keyof T]: Prettify<T[K]>;
} & {};
type Partial2<T> = {
    [K in keyof T]?: Partial<T[K]>;
};
type Reconcile<A extends Object, B extends Object> = {
    [key in keyof A as key extends keyof B ? never : key]: A[key];
} extends infer Collision ? {} extends Collision ? {
    [key in keyof B]: B[key];
} : Prettify<Collision & {
    [key in keyof B]: B[key];
}> : never;
interface SingletonBase {
    decorator: Record<string, unknown>;
    store: Record<string, unknown>;
    derive: Record<string, unknown>;
    resolve: Record<string, unknown>;
}
interface DefinitionBase {
    type: Record<string, unknown>;
    error: Record<string, Error>;
}
type RouteBase = Record<string, unknown>;
interface MetadataBase {
    schema: RouteSchema;
    macro: BaseMacro;
}
interface RouteSchema {
    body?: unknown;
    headers?: unknown;
    query?: unknown;
    params?: unknown;
    cookie?: unknown;
    response?: unknown;
}
type UnwrapSchema<Schema extends TSchema | string | undefined, Definitions extends Record<string, unknown> = {}> = undefined extends Schema ? unknown : Schema extends TSchema ? Static<NonNullable<Schema>> : Schema extends string ? Definitions extends Record<Schema, infer NamedSchema> ? NamedSchema : Definitions : unknown;
interface UnwrapRoute<in out Schema extends InputSchema<any>, in out Definitions extends DefinitionBase['type'] = {}> {
    body: UnwrapSchema<Schema['body'], Definitions>;
    headers: UnwrapSchema<Schema['headers'], Definitions>;
    query: UnwrapSchema<Schema['query'], Definitions>;
    params: UnwrapSchema<Schema['params'], Definitions>;
    cookie: UnwrapSchema<Schema['cookie'], Definitions>;
    response: Schema['response'] extends TSchema | string ? UnwrapSchema<Schema['response'], Definitions> : Schema['response'] extends {
        200: TAnySchema | string;
    } ? {
        [k in keyof Schema['response']]: UnwrapSchema<Schema['response'][k], Definitions>;
    } : unknown | void;
}
interface UnwrapGroupGuardRoute<in out Schema extends InputSchema<any>, in out Definitions extends Record<string, unknown> = {}, Path extends string = ''> {
    body: UnwrapSchema<Schema['body'], Definitions>;
    headers: UnwrapSchema<Schema['headers'], Definitions> extends infer A extends Record<string, unknown> ? A : undefined;
    query: UnwrapSchema<Schema['query'], Definitions> extends infer A extends Record<string, unknown> ? A : undefined;
    params: UnwrapSchema<Schema['params'], Definitions> extends infer A extends Record<string, unknown> ? A : Path extends `${string}/${':' | '*'}${string}` ? Record<GetPathParameter<Path>, string> : never;
    cookie: UnwrapSchema<Schema['cookie'], Definitions> extends infer A extends Record<string, unknown> ? A : undefined;
    response: Schema['response'] extends TSchema | string ? UnwrapSchema<Schema['response'], Definitions> : Schema['response'] extends {
        [k in string]: TSchema | string;
    } ? UnwrapSchema<Schema['response'][keyof Schema['response']], Definitions> : unknown | void;
}
interface LifeCycleStore {
    type?: ContentType;
    start: GracefulHandler<any>[];
    request: PreHandler<any, any>[];
    parse: BodyHandler<any, any>[];
    transform: TransformHandler<any, any>[];
    beforeHandle: OptionalHandler<any, any>[];
    afterHandle: AfterHandler<any, any>[];
    mapResponse: MapResponse<any, any>[];
    onResponse: VoidHandler<any, any>[];
    trace: TraceHandler<any, any>[];
    error: ErrorHandler<any, any, any>[];
    stop: GracefulHandler<any>[];
}
type LifeCycleEvent = 'start' | 'request' | 'parse' | 'transform' | 'beforeHandle' | 'afterHandle' | 'response' | 'error' | 'stop';
type ContentType = MaybeArray<(string & {}) | 'none' | 'text' | 'json' | 'formdata' | 'urlencoded' | 'arrayBuffer' | 'text/plain' | 'application/json' | 'multipart/form-data' | 'application/x-www-form-urlencoded'>;
type HTTPMethod = (string & {}) | 'ACL' | 'BIND' | 'CHECKOUT' | 'CONNECT' | 'COPY' | 'DELETE' | 'GET' | 'HEAD' | 'LINK' | 'LOCK' | 'M-SEARCH' | 'MERGE' | 'MKACTIVITY' | 'MKCALENDAR' | 'MKCOL' | 'MOVE' | 'NOTIFY' | 'OPTIONS' | 'PATCH' | 'POST' | 'PROPFIND' | 'PROPPATCH' | 'PURGE' | 'PUT' | 'REBIND' | 'REPORT' | 'SEARCH' | 'SOURCE' | 'SUBSCRIBE' | 'TRACE' | 'UNBIND' | 'UNLINK' | 'UNLOCK' | 'UNSUBSCRIBE' | 'ALL';
interface InputSchema<Name extends string = string> {
    body?: TSchema | Name;
    headers?: TObject | Name;
    query?: TObject | Name;
    params?: TObject | Name;
    cookie?: TObject | Name;
    response?: TSchema | Record<number, TSchema> | Name | Record<number, Name | TSchema>;
}
interface MergeSchema<in out A extends RouteSchema, in out B extends RouteSchema> {
    body: undefined extends A['body'] ? B['body'] : A['body'];
    headers: undefined extends A['headers'] ? B['headers'] : A['headers'];
    query: undefined extends A['query'] ? B['query'] : A['query'];
    params: undefined extends A['params'] ? B['params'] : A['params'];
    cookie: undefined extends A['cookie'] ? B['cookie'] : A['cookie'];
    response: undefined extends A['response'] ? B['response'] : A['response'];
}
type Handler<in out Route extends RouteSchema = {}, in out Singleton extends SingletonBase = {
    decorator: {};
    store: {};
    derive: {};
    resolve: {};
}, Path extends string = ''> = (context: Context<Route, Singleton, Path>) => Route['response'] extends {
    200: unknown;
} ? Response | MaybePromise<Route['response'][keyof Route['response']]> : Response | MaybePromise<Route['response']>;
type InlineHandler<Route extends RouteSchema = {}, Singleton extends SingletonBase = {
    decorator: {};
    store: {};
    derive: {};
    resolve: {};
}, Path extends string = ''> = ((context: Context<Route, Singleton, Path>) => Route['response'] extends {
    200: unknown;
} ? Response | MaybePromise<Route['response'][keyof Route['response']] | {
    [Status in keyof Route['response']]: {
        _type: Record<Status, Route['response'][Status]>;
        [ELYSIA_RESPONSE]: Status;
    };
}[keyof Route['response']]> : Response | MaybePromise<Route['response']>) | (unknown extends Route['response'] ? string | number | Object : Route['response'] extends {
    200: unknown;
} ? Route['response'][keyof Route['response']] : Route['response']);
type OptionalHandler<in out Route extends RouteSchema = {}, in out Singleton extends SingletonBase = {
    decorator: {};
    store: {};
    derive: {};
    resolve: {};
}> = Handler<Route, Singleton> extends (context: infer Context) => infer Returned ? (context: Context) => Returned | MaybePromise<void> : never;
type AfterHandler<in out Route extends RouteSchema = {}, in out Singleton extends SingletonBase = {
    decorator: {};
    store: {};
    derive: {};
    resolve: {};
}> = Handler<Route, Singleton> extends (context: infer Context) => infer Returned ? (context: Prettify<{
    response: Route['response'];
} & Context>) => Returned | MaybePromise<void> : never;
type MapResponse<in out Route extends RouteSchema = {}, in out Singleton extends SingletonBase = {
    decorator: {};
    store: {};
    derive: {};
    resolve: {};
}> = Handler<Omit<Route, 'response'> & {
    response: MaybePromise<Response | undefined | void>;
}, Singleton & {
    derive: {
        response: Route['response'];
    };
}>;
type VoidHandler<in out Route extends RouteSchema = {}, in out Singleton extends SingletonBase = {
    decorator: {};
    store: {};
    derive: {};
    resolve: {};
}> = (context: Context<Route, Singleton>) => MaybePromise<void>;
type TransformHandler<in out Route extends RouteSchema = {}, in out Singleton extends SingletonBase = {
    decorator: {};
    store: {};
    derive: {};
    resolve: {};
}> = {
    (context: Prettify<Context<Route, Omit<Singleton, 'resolve'> & {
        resolve: {};
    }>>): MaybePromise<void>;
    $elysiaHookType?: LifeCycleType;
    $elysiaChecksum?: number;
    $elysia?: 'derive' | 'resolve' | (string & {});
};
type TraceEvent = 'request' | 'parse' | 'transform' | 'beforeHandle' | 'afterHandle' | 'error' | 'response' extends infer Events extends string ? Events | `${Events}.unit` | 'handle' | 'exit' : never;
type TraceStream = {
    id: number;
    event: TraceEvent;
    type: 'begin' | 'end';
    time: number;
    name?: string;
    unit?: number;
};
type TraceReporter = EventEmitter<{
    [res in `res${number}.${number}`]: undefined;
} & {
    event(stream: TraceStream): MaybePromise<void>;
}>;
type TraceProcess<Type extends 'begin' | 'end' = 'begin' | 'end'> = Type extends 'begin' ? Prettify<{
    name: string;
    time: number;
    skip: boolean;
    end: Promise<TraceProcess<'end'>>;
    children: Promise<TraceProcess<'begin'>>[];
}> : number;
type TraceHandler<in out Route extends RouteSchema = {}, in out Singleton extends SingletonBase = {
    decorator: {};
    store: {};
    derive: {};
    resolve: {};
}> = {
    (lifecycle: Prettify<{
        context: Context<Route, Singleton>;
        set: Context['set'];
        id: number;
        time: number;
    } & {
        [x in 'request' | 'parse' | 'transform' | 'beforeHandle' | 'handle' | 'afterHandle' | 'error' | 'response']: Promise<TraceProcess<'begin'>>;
    } & {
        store: Singleton['store'];
    }>): MaybePromise<void>;
    $elysiaHookType?: LifeCycleType;
    $elysiaChecksum?: number;
};
type TraceListener = EventEmitter<{
    [event in TraceEvent | 'all']: (trace: TraceProcess) => MaybePromise<void>;
}>;
type BodyHandler<in out Route extends RouteSchema = {}, in out Singleton extends SingletonBase = {
    decorator: {};
    store: {};
    derive: {};
    resolve: {};
}> = (context: Context<Route, Singleton>, contentType: string) => MaybePromise<any>;
type PreHandler<in out Route extends RouteSchema = {}, in out Singleton extends SingletonBase = {
    decorator: {};
    store: {};
    derive: {};
    resolve: {};
}> = (context: PreContext<Singleton>) => MaybePromise<Route['response'] | void>;
type GracefulHandler<in Instance extends Elysia<any, any, any, any, any, any, any, any>> = (data: Instance) => any;
type ErrorHandler<T extends Record<string, Error> = {}, Route extends RouteSchema = {}, Singleton extends SingletonBase = {
    decorator: {};
    store: {};
    derive: {};
    resolve: {};
}> = (context: Prettify<Omit<Context<Route, Singleton>, 'error'> & ({
    request: Request;
    code: 'UNKNOWN';
    error: Readonly<Error>;
    set: Context['set'];
} | {
    request: Request;
    code: 'VALIDATION';
    error: Readonly<ValidationError>;
    set: Context['set'];
} | {
    request: Request;
    code: 'NOT_FOUND';
    error: Readonly<NotFoundError>;
    set: Context['set'];
} | {
    request: Request;
    code: 'PARSE';
    error: Readonly<ParseError>;
    set: Context['set'];
} | {
    request: Request;
    code: 'INTERNAL_SERVER_ERROR';
    error: Readonly<InternalServerError>;
    set: Context['set'];
} | {
    request: Request;
    code: 'INVALID_COOKIE_SIGNATURE';
    error: Readonly<InvalidCookieSignature>;
    set: Context['set'];
} | {
    [K in keyof T]: {
        request: Request;
        code: K;
        error: Readonly<T[K]>;
        set: Context['set'];
    };
}[keyof T])>) => any | Promise<any>;
type Isolate<T> = {
    [P in keyof T]: T[P];
};
type LocalHookDetail = Partial<OpenAPIV3.OperationObject>;
type LocalHook<LocalSchema extends InputSchema, Schema extends RouteSchema, Singleton extends SingletonBase, Errors extends Record<string, Error>, Extension extends BaseMacro, Path extends string = '', TypedRoute extends RouteSchema = Schema extends {
    params: Record<string, unknown>;
} ? Schema : Schema & {
    params: undefined extends Schema['params'] ? Record<GetPathParameter<Path>, string> : Schema['params'];
}> = (LocalSchema extends {} ? LocalSchema : Isolate<LocalSchema>) & Extension & {
    /**
     * Short for 'Content-Type'
     *
     * Available:
     * - 'none': do not parse body
     * - 'text' / 'text/plain': parse body as string
     * - 'json' / 'application/json': parse body as json
     * - 'formdata' / 'multipart/form-data': parse body as form-data
     * - 'urlencoded' / 'application/x-www-form-urlencoded: parse body as urlencoded
     * - 'arraybuffer': parse body as readable stream
     */
    type?: ContentType;
    detail?: LocalHookDetail;
    /**
     * Custom body parser
     */
    parse?: MaybeArray<BodyHandler<TypedRoute, Singleton>>;
    /**
     * Transform context's value
     */
    transform?: MaybeArray<TransformHandler<TypedRoute, Singleton>>;
    /**
     * Execute before main handler
     */
    beforeHandle?: MaybeArray<OptionalHandler<TypedRoute, Singleton>>;
    /**
     * Execute after main handler
     */
    afterHandle?: MaybeArray<AfterHandler<TypedRoute, Singleton>>;
    /**
     * Execute after main handler
     */
    mapResponse?: MaybeArray<MapResponse<TypedRoute, Singleton>>;
    /**
     * Catch error
     */
    error?: MaybeArray<ErrorHandler<Errors, TypedRoute, Singleton>>;
    /**
     * Custom body parser
     */
    onResponse?: MaybeArray<VoidHandler<TypedRoute, Singleton>>;
};
type ComposedHandler = {
    (context: Context): MaybePromise<Response>;
    compose(): Function;
    composed: Function;
};
interface InternalRoute {
    method: HTTPMethod;
    path: string;
    composed: ComposedHandler | Response | null;
    handler: Handler;
    hooks: LocalHook<any, any, any, any, any, any, any>;
}
type SchemaValidator = {
    body?: TypeCheck<any>;
    headers?: TypeCheck<any>;
    query?: TypeCheck<any>;
    params?: TypeCheck<any>;
    cookie?: TypeCheck<any>;
    response?: Record<number, TypeCheck<any>>;
};
type ListenCallback = (server: Server) => MaybePromise<void>;
type AddPrefix<Prefix extends string, T> = {
    [K in keyof T as Prefix extends string ? `${Prefix}${K & string}` : K]: T[K];
};
type AddPrefixCapitalize<Prefix extends string, T> = {
    [K in keyof T as `${Prefix}${Capitalize<K & string>}`]: T[K];
};
type AddSuffix<Suffix extends string, T> = {
    [K in keyof T as `${K & string}${Suffix}`]: T[K];
};
type AddSuffixCapitalize<Suffix extends string, T> = {
    [K in keyof T as `${K & string}${Capitalize<Suffix>}`]: T[K];
};
type Checksum = {
    name?: string;
    seed?: unknown;
    checksum: number;
    stack?: string;
    routes?: InternalRoute[];
    decorators?: SingletonBase['decorator'];
    store?: SingletonBase['store'];
    type?: DefinitionBase['type'];
    error?: DefinitionBase['error'];
    dependencies?: Record<string, Checksum[]>;
    derive?: {
        fn: string;
        stack: string;
    }[];
    resolve?: {
        fn: string;
        stack: string;
    }[];
};
type BaseMacro = Record<string, Record<string, unknown> | ((...a: any) => unknown)>;
type MacroToProperty<in out T extends BaseMacro> = Prettify<{
    [K in keyof T]: T[K] extends Function ? T[K] extends (a: infer Params) => any ? Params | undefined : T[K] : T[K] extends BaseMacro ? MacroToProperty<T[K]> : never;
}>;
type ElysiaFn = {
    (...a: any[]): any;
    $elysiaHookType?: LifeCycleType;
    $elysiaChecksum?: number;
};
interface MacroManager<in out TypedRoute extends RouteSchema = {}, in out Singleton extends SingletonBase = {
    decorator: {};
    store: {};
    derive: {};
    resolve: {};
}, in out Errors extends Record<string, Error> = {}> {
    onParse(fn: MaybeArray<BodyHandler<TypedRoute, Singleton>>): unknown;
    onParse(options: {
        insert?: 'before' | 'after';
        stack?: 'global' | 'local';
    }, fn: MaybeArray<BodyHandler<TypedRoute, Singleton>>): unknown;
    onTransform(fn: MaybeArray<VoidHandler<TypedRoute, Singleton>>): unknown;
    onTransform(options: {
        insert?: 'before' | 'after';
        stack?: 'global' | 'local';
    }, fn: MaybeArray<VoidHandler<TypedRoute, Singleton>>): unknown;
    onBeforeHandle(fn: MaybeArray<OptionalHandler<TypedRoute, Singleton>>): unknown;
    onBeforeHandle(options: {
        insert?: 'before' | 'after';
        stack?: 'global' | 'local';
    }, fn: MaybeArray<OptionalHandler<TypedRoute, Singleton>>): unknown;
    onAfterHandle(fn: MaybeArray<AfterHandler<TypedRoute, Singleton>>): unknown;
    onAfterHandle(options: {
        insert?: 'before' | 'after';
        stack?: 'global' | 'local';
    }, fn: MaybeArray<AfterHandler<TypedRoute, Singleton>>): unknown;
    onError(fn: MaybeArray<ErrorHandler<Errors, TypedRoute, Singleton>>): unknown;
    onError(options: {
        insert?: 'before' | 'after';
        stack?: 'global' | 'local';
    }, fn: MaybeArray<ErrorHandler<Errors, TypedRoute, Singleton>>): unknown;
    onResponse(fn: MaybeArray<VoidHandler<TypedRoute, Singleton>>): unknown;
    onResponse(options: {
        insert?: 'before' | 'after';
        stack?: 'global' | 'local';
    }, fn: MaybeArray<VoidHandler<TypedRoute, Singleton>>): unknown;
    events: {
        global: Prettify<LifeCycleStore & RouteSchema>;
        local: Prettify<LifeCycleStore & RouteSchema>;
    };
}
type MacroQueue = {
    (manager: MacroManager<any, any, any>): unknown;
    $elysiaChecksum?: number;
}[];
type _CreateEden<Path extends string, Property extends Record<string, unknown> = {}> = Path extends `${infer Start}/${infer Rest}` ? {
    [x in Start]: _CreateEden<Rest, Property>;
} : {
    [x in Path]: Property;
};
type CreateEden<Path extends string, Property extends Record<string, unknown> = {}> = Path extends `/${infer Rest}` ? _CreateEden<Rest, Property> : Path extends '' ? _CreateEden<'index', Property> : _CreateEden<Path, Property>;
type ComposeElysiaResponse<Response, Handle> = Handle extends (...a: any[]) => infer A ? _ComposeElysiaResponse<Response, Awaited<A>> : _ComposeElysiaResponse<Response, Awaited<Handle>>;
type _ComposeElysiaResponse<Response, Handle> = Prettify<unknown extends Response ? {
    200: Exclude<Handle, {
        [ELYSIA_RESPONSE]: any;
    }>;
} & {
    [ErrorResponse in Extract<Handle, {
        response: any;
    }> as ErrorResponse extends {
        [ELYSIA_RESPONSE]: infer Status extends number;
    } ? Status : never]: ErrorResponse['response'];
} : Response extends {
    200: unknown;
} ? Response : {
    200: Response;
}>;
type MergeElysiaInstances<Instances extends Elysia<any, any, any, any, any, any>[] = [], Prefix extends string = '', Scoped extends boolean = false, Singleton extends SingletonBase = {
    decorator: {};
    store: {};
    derive: {};
    resolve: {};
}, Definitions extends DefinitionBase = {
    type: {};
    error: {};
}, Metadata extends MetadataBase = {
    schema: {};
    macro: {};
}, Routes extends RouteBase = {}> = Instances extends [
    infer Current extends Elysia<any, any, any, any, any, any>,
    ...infer Rest extends Elysia<any, any, any, any, any, any>[]
] ? Current['_types']['Scoped'] extends true ? MergeElysiaInstances<Rest, Prefix, Scoped, Singleton, Definitions, Metadata, Routes> : MergeElysiaInstances<Rest, Prefix, Scoped, Singleton & Current['_types']['Singleton'], Definitions & Current['_types']['Definitions'], Metadata & Current['_types']['Metadata'], Routes & (Prefix extends `` ? Current['_routes'] : AddPrefix<Prefix, Current['_routes']>)> : Elysia<Prefix, Scoped, {
    decorator: Prettify<Singleton['decorator']>;
    store: Prettify<Singleton['store']>;
    derive: Prettify<Singleton['derive']>;
    resolve: Prettify<Singleton['resolve']>;
}, {
    type: Prettify<Definitions['type']>;
    error: Prettify<Definitions['error']>;
}, {
    schema: Prettify<Metadata['schema']>;
    macro: Prettify<Metadata['macro']>;
}, Routes>;
type LifeCycleType = 'global' | 'local' | 'scoped';

declare const replaceUrlPath: (url: string, pathname: string) => string;
declare const mergeDeep: <A extends Record<string, any>, B extends Record<string, any>>(target: A, source: B, { skipKeys }?: {
    skipKeys?: string[] | undefined;
}) => A & B;
declare const mergeCookie: <const A extends Object, const B extends Object>(a: A, b: B) => A & B;
declare const mergeObjectArray: <T extends ElysiaFn>(a?: T | T[], b?: T | T[]) => T[];
declare const primitiveHooks: readonly ["start", "request", "parse", "transform", "resolve", "beforeHandle", "afterHandle", "onResponse", "mapResponse", "trace", "error", "stop", "body", "headers", "params", "query", "response", "type", "detail"];
declare const mergeHook: (a?: LocalHook<any, any, any, any, any, any, any> | LifeCycleStore, b?: LocalHook<any, any, any, any, any, any, any>) => LifeCycleStore;
declare const getSchemaValidator: (s: TSchema | string | undefined, { models, additionalProperties, dynamic }: {
    models?: Record<string, TSchema> | undefined;
    additionalProperties?: boolean | undefined;
    dynamic?: boolean | undefined;
}) => TypeCheck<TSchema> | undefined;
declare const getResponseSchemaValidator: (s: InputSchema['response'] | undefined, { models, additionalProperties, dynamic }: {
    models?: Record<string, TSchema> | undefined;
    additionalProperties?: boolean | undefined;
    dynamic?: boolean | undefined;
}) => Record<number, TypeCheck<any>> | undefined;
declare const checksum: (s: string) => number;
declare const getCookieValidator: ({ validator, defaultConfig, config, dynamic, models }: {
    validator: TSchema | string | undefined;
    defaultConfig: CookieOptions | undefined;
    config: CookieOptions;
    dynamic: boolean;
    models: Record<string, TSchema> | undefined;
}) => TypeCheck<TSchema> | undefined;
declare const mergeLifeCycle: (a: LifeCycleStore, b: LifeCycleStore | LocalHook<any, any, any, any, any, any, any>, checksum?: number) => LifeCycleStore;
declare const asHookType: <T extends MaybeArray<ElysiaFn> | undefined>(fn: T, inject: LifeCycleType, { skipIfHasType }?: {
    skipIfHasType?: boolean | undefined;
}) => T;
declare const filterGlobalHook: (hook: LocalHook<any, any, any, any, any, any, any>) => LocalHook<any, any, any, any, any, any, any>;
declare const StatusMap: {
    readonly Continue: 100;
    readonly 'Switching Protocols': 101;
    readonly Processing: 102;
    readonly 'Early Hints': 103;
    readonly OK: 200;
    readonly Created: 201;
    readonly Accepted: 202;
    readonly 'Non-Authoritative Information': 203;
    readonly 'No Content': 204;
    readonly 'Reset Content': 205;
    readonly 'Partial Content': 206;
    readonly 'Multi-Status': 207;
    readonly 'Already Reported': 208;
    readonly 'Multiple Choices': 300;
    readonly 'Moved Permanently': 301;
    readonly Found: 302;
    readonly 'See Other': 303;
    readonly 'Not Modified': 304;
    readonly 'Temporary Redirect': 307;
    readonly 'Permanent Redirect': 308;
    readonly 'Bad Request': 400;
    readonly Unauthorized: 401;
    readonly 'Payment Required': 402;
    readonly Forbidden: 403;
    readonly 'Not Found': 404;
    readonly 'Method Not Allowed': 405;
    readonly 'Not Acceptable': 406;
    readonly 'Proxy Authentication Required': 407;
    readonly 'Request Timeout': 408;
    readonly Conflict: 409;
    readonly Gone: 410;
    readonly 'Length Required': 411;
    readonly 'Precondition Failed': 412;
    readonly 'Payload Too Large': 413;
    readonly 'URI Too Long': 414;
    readonly 'Unsupported Media Type': 415;
    readonly 'Range Not Satisfiable': 416;
    readonly 'Expectation Failed': 417;
    readonly "I'm a teapot": 418;
    readonly 'Misdirected Request': 421;
    readonly 'Unprocessable Content': 422;
    readonly Locked: 423;
    readonly 'Failed Dependency': 424;
    readonly 'Too Early': 425;
    readonly 'Upgrade Required': 426;
    readonly 'Precondition Required': 428;
    readonly 'Too Many Requests': 429;
    readonly 'Request Header Fields Too Large': 431;
    readonly 'Unavailable For Legal Reasons': 451;
    readonly 'Internal Server Error': 500;
    readonly 'Not Implemented': 501;
    readonly 'Bad Gateway': 502;
    readonly 'Service Unavailable': 503;
    readonly 'Gateway Timeout': 504;
    readonly 'HTTP Version Not Supported': 505;
    readonly 'Variant Also Negotiates': 506;
    readonly 'Insufficient Storage': 507;
    readonly 'Loop Detected': 508;
    readonly 'Not Extended': 510;
    readonly 'Network Authentication Required': 511;
};
type StatusMap = typeof StatusMap;
declare const InvertedStatusMap: {
    readonly 100: "Continue";
    readonly 101: "Switching Protocols";
    readonly 102: "Processing";
    readonly 103: "Early Hints";
    readonly 200: "OK";
    readonly 201: "Created";
    readonly 202: "Accepted";
    readonly 203: "Non-Authoritative Information";
    readonly 204: "No Content";
    readonly 205: "Reset Content";
    readonly 206: "Partial Content";
    readonly 207: "Multi-Status";
    readonly 208: "Already Reported";
    readonly 300: "Multiple Choices";
    readonly 301: "Moved Permanently";
    readonly 302: "Found";
    readonly 303: "See Other";
    readonly 304: "Not Modified";
    readonly 307: "Temporary Redirect";
    readonly 308: "Permanent Redirect";
    readonly 400: "Bad Request";
    readonly 401: "Unauthorized";
    readonly 402: "Payment Required";
    readonly 403: "Forbidden";
    readonly 404: "Not Found";
    readonly 405: "Method Not Allowed";
    readonly 406: "Not Acceptable";
    readonly 407: "Proxy Authentication Required";
    readonly 408: "Request Timeout";
    readonly 409: "Conflict";
    readonly 410: "Gone";
    readonly 411: "Length Required";
    readonly 412: "Precondition Failed";
    readonly 413: "Payload Too Large";
    readonly 414: "URI Too Long";
    readonly 415: "Unsupported Media Type";
    readonly 416: "Range Not Satisfiable";
    readonly 417: "Expectation Failed";
    readonly 418: "I'm a teapot";
    readonly 421: "Misdirected Request";
    readonly 422: "Unprocessable Content";
    readonly 423: "Locked";
    readonly 424: "Failed Dependency";
    readonly 425: "Too Early";
    readonly 426: "Upgrade Required";
    readonly 428: "Precondition Required";
    readonly 429: "Too Many Requests";
    readonly 431: "Request Header Fields Too Large";
    readonly 451: "Unavailable For Legal Reasons";
    readonly 500: "Internal Server Error";
    readonly 501: "Not Implemented";
    readonly 502: "Bad Gateway";
    readonly 503: "Service Unavailable";
    readonly 504: "Gateway Timeout";
    readonly 505: "HTTP Version Not Supported";
    readonly 506: "Variant Also Negotiates";
    readonly 507: "Insufficient Storage";
    readonly 508: "Loop Detected";
    readonly 510: "Not Extended";
    readonly 511: "Network Authentication Required";
};
type InvertedStatusMap = typeof InvertedStatusMap;
declare const signCookie: (val: string, secret: string | null) => Promise<string>;
declare const unsignCookie: (input: string, secret: string | null) => Promise<string | false>;
declare const traceBackMacro: (extension: unknown, property: Record<string, unknown>, hooks?: Record<string, unknown>) => void;
declare const createMacroManager: ({ globalHook, localHook }: {
    globalHook: LifeCycleStore;
    localHook: LocalHook<any, any, any, any, any, any, any>;
}) => (stackName: keyof LifeCycleStore) => (type: {
    insert?: 'before' | 'after';
    stack?: 'global' | 'local';
} | MaybeArray<Function>, fn?: MaybeArray<Function>) => void;
declare const isNumericString: (message: string) => boolean;

type InvertedStatusMapKey = keyof InvertedStatusMap;
type WithoutNullableKeys<Type> = {
    [Key in keyof Type]-?: NonNullable<Type[Key]>;
};
type Context<in out Route extends RouteSchema = {}, in out Singleton extends SingletonBase = {
    decorator: {};
    store: {};
    derive: {};
    resolve: {};
}, Path extends string = ''> = Prettify<{
    body: Route['body'];
    query: undefined extends Route['query'] ? Record<string, string | undefined> : Route['query'];
    params: undefined extends Route['params'] ? Path extends `${string}/${':' | '*'}${string}` ? Record<GetPathParameter<Path>, string> : never : Route['params'];
    headers: undefined extends Route['headers'] ? Record<string, string | undefined> : Route['headers'];
    cookie: undefined extends Route['cookie'] ? Record<string, Cookie<any>> : Record<string, Cookie<any>> & WithoutNullableKeys<{
        [key in keyof Route['cookie']]: Cookie<Route['cookie'][key]>;
    }>;
    set: {
        headers: Record<string, string> & {
            'Set-Cookie'?: string | string[];
        };
        status?: number | keyof StatusMap;
        redirect?: string;
        /**
         * ! Internal Property
         *
         * Use `Context.cookie` instead
         */
        cookie?: Record<string, ElysiaCookie>;
    };
    path: string;
    request: Request;
    store: Singleton['store'];
} & (Route['response'] extends {
    200: unknown;
} ? {
    error: <const Code extends keyof Route['response'] | InvertedStatusMap[Extract<InvertedStatusMapKey, keyof Route['response']>], const T extends Code extends keyof Route['response'] ? Route['response'][Code] : Code extends keyof StatusMap ? Route['response'][StatusMap[Code]] : never>(code: Code, response: T) => {
        [ELYSIA_RESPONSE]: Code extends keyof StatusMap ? StatusMap[Code] : Code;
        response: T;
        _type: {
            [ERROR_CODE in Code extends keyof StatusMap ? StatusMap[Code] : Code]: T;
        };
    };
} : {
    error: typeof error;
}) & Singleton['decorator'] & Singleton['derive'] & Singleton['resolve']>;
type PreContext<in out Singleton extends SingletonBase = {
    decorator: {};
    store: {};
    derive: {};
    resolve: {};
}> = Prettify<{
    store: Singleton['store'];
    request: Request;
    set: {
        headers: {
            [header: string]: string;
        } & {
            ['Set-Cookie']?: string | string[];
        };
        status?: number;
        redirect?: string;
    };
    error: typeof error;
} & Singleton['decorator']>;

declare const t: _sinclair_typebox.JavaScriptTypeBuilder;
declare namespace ElysiaTypeOptions {
    type Numeric = NumberOptions;
    type FileUnit = number | `${number}${'k' | 'm'}`;
    interface File extends SchemaOptions {
        type?: MaybeArray<(string & {}) | 'image' | 'image/jpeg' | 'image/png' | 'image/gif' | 'image/tiff' | 'image/x-icon' | 'image/svg' | 'image/webp' | 'image/avif' | 'audio' | 'audio/mpeg' | 'audio/x-ms-wma' | 'audio/vnd.rn-realaudio' | 'audio/x-wav' | 'video' | 'video/mpeg' | 'video/mp4' | 'video/quicktime' | 'video/x-ms-wmv' | 'video/x-msvideo' | 'video/x-flv' | 'video/webm' | 'text' | 'text/css' | 'text/csv' | 'text/html' | 'text/javascript' | 'text/plain' | 'text/xml' | 'application' | 'application/ogg' | 'application/pdf' | 'application/xhtml' | 'application/html' | 'application/json' | 'application/ld+json' | 'application/xml' | 'application/zip' | 'font' | 'font/woff2' | 'font/woff' | 'font/ttf' | 'font/otf'>;
        minSize?: FileUnit;
        maxSize?: FileUnit;
    }
    interface Files extends File {
        minItems?: number;
        maxItems?: number;
    }
}
declare const ElysiaType: {
    readonly Numeric: (property?: NumberOptions) => TNumber;
    readonly Date: (property?: DateOptions) => TDate;
    readonly BooleanString: (property?: SchemaOptions) => TBoolean;
    readonly ObjectString: <T extends TProperties = {}>(properties?: T, options?: ObjectOptions) => TObject<T>;
    readonly File: (options?: Partial<ElysiaTypeOptions.File> | undefined) => _sinclair_typebox.TUnsafe<File>;
    readonly Files: (options?: ElysiaTypeOptions.Files) => _sinclair_typebox.TTransform<_sinclair_typebox.TUnsafe<File[]>, File[]>;
    readonly Nullable: <T extends TSchema>(schema: T) => TUnion<[T, TNull]>;
    /**
     * Allow Optional, Nullable and Undefined
     */
    readonly MaybeEmpty: <T_1 extends TSchema>(schema: T_1) => TUnion<[T_1, TUndefined]>;
    readonly Cookie: <T_2 extends TProperties>(properties: T_2, options?: (ObjectOptions & CookieOptions & {
        /**
         * Secret key for signing cookie
         *
         * If array is passed, will use Key Rotation.
         *
         * Key rotation is when an encryption key is retired
         * and replaced by generating a new cryptographic key.
         */
        secrets?: string | string[] | undefined;
        /**
         * Specified cookie name to be signed globally
         */
        sign?: readonly ((string & {}) | keyof T_2)[] | undefined;
    }) | undefined) => TObject<T_2>;
};
type TCookie = (typeof ElysiaType)['Cookie'];
declare module '@sinclair/typebox' {
    interface JavaScriptTypeBuilder {
        BooleanString: typeof ElysiaType.BooleanString;
        ObjectString: typeof ElysiaType.ObjectString;
        Numeric: typeof ElysiaType.Numeric;
        File: typeof ElysiaType.File;
        Files: typeof ElysiaType.Files;
        Nullable: typeof ElysiaType.Nullable;
        MaybeEmpty: typeof ElysiaType.MaybeEmpty;
        Cookie: typeof ElysiaType.Cookie;
    }
    interface SchemaOptions {
        error?: string | ((type: string, validator: TypeCheck<any>, value: unknown) => string | void);
    }
}

declare const websocket: WebSocketHandler<any>;
declare class ElysiaWS<WS extends ServerWebSocket<{
    id?: string;
    validator?: TypeCheck<TSchema>;
}>, Route extends RouteSchema = RouteSchema, Singleton extends SingletonBase = {
    decorator: {};
    store: {};
    derive: {};
    resolve: {};
}> {
    raw: WS;
    data: Context<Route, Singleton>;
    validator?: TypeCheck<TSchema>;
    constructor(raw: WS, data: Context<Route, Singleton>);
    get id(): string;
    set id(newID: string);
    get publish(): (topic: string, data?: Route['response'], compress?: boolean) => this;
    get send(): (data: Route['response']) => this;
    get subscribe(): (room: string) => this;
    get unsubscribe(): (room: string) => this;
    get cork(): (callback: () => this) => this;
    get close(): () => this;
    get terminate(): () => void;
    get isSubscribed(): (topic: string) => boolean;
    get remoteAddress(): string;
}

declare namespace WS {
    type Config = Omit<WebSocketHandler, 'open' | 'message' | 'close' | 'drain'>;
    type LocalHook<LocalSchema extends InputSchema, Route extends RouteSchema, Singleton extends SingletonBase, Errors extends Record<string, Error>, Extension extends BaseMacro, Path extends string = '', TypedRoute extends RouteSchema = keyof Route['params'] extends never ? Route & {
        params: Record<GetPathParameter<Path>, string>;
    } : Route> = (LocalSchema extends {} ? LocalSchema : Isolate<LocalSchema>) & Extension & Omit<Partial<WebSocketHandler<Context>>, 'open' | 'message' | 'close' | 'drain' | 'publish' | 'publishToSelf'> & (ElysiaWS<ServerWebSocket<{
        validator?: TypeCheck<TSchema>;
    }>, TypedRoute, Singleton> extends infer WS ? {
        transform?: MaybeArray<VoidHandler<TypedRoute, Singleton>>;
        transformMessage?: MaybeArray<VoidHandler<TypedRoute, Singleton>>;
        beforeHandle?: MaybeArray<Handler<TypedRoute, Singleton>>;
        /**
         * Catch error
         */
        error?: MaybeArray<ErrorHandler<Errors>>;
        /**
         * Headers to register to websocket before `upgrade`
         */
        upgrade?: Bun.HeadersInit | ((context: Context) => Bun.HeadersInit);
        /**
         * The {@link ServerWebSocket} has been opened
         *
         * @param ws The {@link ServerWebSocket} that was opened
         */
        open?: (ws: WS) => void | Promise<void>;
        /**
         * Handle an incoming message to a {@link ServerWebSocket}
         *
         * @param ws The {@link ServerWebSocket} that received the message
         * @param message The message received
         *
         * To change `message` to be an `ArrayBuffer` instead of a `Uint8Array`, set `ws.binaryType = "arraybuffer"`
         */
        message?: (ws: WS, message: Route['body']) => any;
        /**
         * The {@link ServerWebSocket} is being closed
         * @param ws The {@link ServerWebSocket} that was closed
         * @param code The close code
         * @param message The close message
         */
        close?: (ws: WS, code: number, message: string) => void | Promise<void>;
        /**
         * The {@link ServerWebSocket} is ready for more data
         *
         * @param ws The {@link ServerWebSocket} that is ready
         */
        drain?: (ws: WS) => void | Promise<void>;
    } : {});
}

declare const isNotEmpty: (obj: Object) => boolean;
declare const parseSetCookies: (headers: Headers, setCookie: string[]) => Headers;
declare const serializeCookie: (cookies: Context['set']['cookie']) => string | string[] | undefined;
declare const mapResponse: (response: unknown, set: Context['set'], request?: Request) => Response;
declare const mapEarlyResponse: (response: unknown, set: Context['set'], request?: Request) => Response | undefined;
declare const mapCompactResponse: (response: unknown, request?: Request) => Response;
declare const errorToResponse: (error: Error, set?: Context['set']) => undici_types.Response;

/**
 * ### Elysia Server
 * Main instance to create web server using Elysia
 *
 * ---
 * @example
 * ```typescript
 * import { Elysia } from 'elysia'
 *
 * new Elysia()
 *     .get("/", () => "Hello")
 *     .listen(8080)
 * ```
 */
declare class Elysia<const in out BasePath extends string = '', const in out Scoped extends boolean = false, const in out Singleton extends SingletonBase = {
    decorator: {};
    store: {};
    derive: {};
    resolve: {};
}, const in out Definitions extends DefinitionBase = {
    type: {};
    error: {};
}, const in out Metadata extends MetadataBase = {
    schema: {};
    macro: {};
}, const out Routes extends RouteBase = {}, const in out EphemeralSingleton extends SingletonBase = {
    decorator: {};
    store: {};
    derive: {};
    resolve: {};
}, const in out EphemeralMetadata extends MetadataBase = {
    schema: {};
    macro: {};
}> {
    config: ElysiaConfig<BasePath, Scoped>;
    server: Server | null;
    private dependencies;
    private reporter;
    _routes: Routes;
    _types: {
        Prefix: BasePath;
        Scoped: Scoped;
        Singleton: Singleton;
        Definitions: Definitions;
        Metadata: Metadata;
    };
    _ephemeral: {
        Singleton: EphemeralSingleton;
        Metadata: EphemeralMetadata;
    };
    protected singleton: Singleton;
    get store(): Singleton['store'];
    get decorator(): Singleton['decorator'];
    protected definitions: {
        type: Record<string, TSchema>;
        error: Record<string, Error>;
    };
    protected extender: {
        macros: MacroQueue;
    };
    protected validator: SchemaValidator | null;
    event: LifeCycleStore;
    telemetry: {
        stack: string | undefined;
    };
    router: {
        http: Memoirist<ComposedHandler>;
        ws: Memoirist<ComposedHandler>;
        dynamic: Memoirist<DynamicHandler>;
        static: {
            http: {
                handlers: ComposedHandler[];
                variables: string;
                map: Record<string, {
                    code: string;
                    all?: string | undefined;
                }>;
                all: string;
            };
            ws: Record<string, number>;
        };
        history: InternalRoute[];
    };
    protected inference: {
        readonly event: {
            readonly body: false;
            readonly cookie: false;
            readonly headers: false;
            readonly queries: [];
            readonly query: false;
            readonly set: false;
            readonly unknownQueries: false;
        };
        readonly trace: {
            readonly request: false;
            readonly parse: false;
            readonly transform: false;
            readonly handle: false;
            readonly beforeHandle: false;
            readonly afterHandle: false;
            readonly error: false;
            readonly context: false;
            readonly store: false;
            readonly set: false;
        };
    };
    private lazyLoadModules;
    constructor(config?: ElysiaConfig<BasePath, Scoped>);
    private getServer;
    get routes(): InternalRoute[];
    protected routeTree: Map<string, number>;
    private add;
    private setHeaders?;
    headers(header: Context['set']['headers'] | undefined): this;
    /**
     * ### start | Life cycle event
     * Called after server is ready for serving
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onStart(({ url, port }) => {
     *         console.log("Running at ${url}:${port}")
     *     })
     *     .listen(8080)
     * ```
     */
    onStart(handler: MaybeArray<GracefulHandler<this>>): this;
    /**
     * ### request | Life cycle event
     * Called on every new request is accepted
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onRequest(({ method, url }) => {
     *         saveToAnalytic({ method, url })
     *     })
     * ```
     */
    onRequest<const Schema extends RouteSchema>(handler: MaybeArray<PreHandler<MergeSchema<Schema, Metadata['schema'] & EphemeralMetadata['schema']>, Singleton & EphemeralSingleton>>): this;
    /**
     * ### parse | Life cycle event
     * Callback function to handle body parsing
     *
     * If truthy value is returned, will be assigned to `context.body`
     * Otherwise will skip the callback and look for the next one.
     *
     * Equivalent to Express's body parser
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onParse((request, contentType) => {
     *         if(contentType === "application/json")
     *             return request.json()
     *     })
     * ```
     */
    onParse(parser: MaybeArray<BodyHandler<Metadata['schema'] & EphemeralMetadata['schema'], Singleton>>): this;
    /**
     * ### parse | Life cycle event
     * Callback function to handle body parsing
     *
     * If truthy value is returned, will be assigned to `context.body`
     * Otherwise will skip the callback and look for the next one.
     *
     * Equivalent to Express's body parser
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onParse((request, contentType) => {
     *         if(contentType === "application/json")
     *             return request.json()
     *     })
     * ```
     */
    onParse(options: {
        as?: LifeCycleType;
    }, parser: MaybeArray<BodyHandler<Metadata['schema'] & EphemeralMetadata['schema'], Singleton & EphemeralSingleton>>): this;
    /**
     * ### transform | Life cycle event
     * Assign or transform anything related to context before validation.
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onTransform(({ params }) => {
     *         if(params.id)
     *             params.id = +params.id
     *     })
     * ```
     */
    onTransform<const Schema extends RouteSchema>(handler: MaybeArray<TransformHandler<MergeSchema<Schema, Metadata['schema'] & EphemeralMetadata['schema']>, Singleton & EphemeralSingleton>>): this;
    /**
     * ### transform | Life cycle event
     * Assign or transform anything related to context before validation.
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onTransform(({ params }) => {
     *         if(params.id)
     *             params.id = +params.id
     *     })
     * ```
     */
    onTransform<const Schema extends RouteSchema>(options: {
        as?: LifeCycleType;
    }, handler: MaybeArray<TransformHandler<MergeSchema<Schema, Metadata['schema'] & EphemeralMetadata['schema']>, Singleton & EphemeralSingleton>>): this;
    /**
     * Derive new property for each request with access to `Context`.
     *
     * If error is thrown, the scope will skip to handling error instead.
     *
     * ---
     * @example
     * new Elysia()
     *     .state('counter', 1)
     *     .derive(({ store }) => ({
     *         increase() {
     *             store.counter++
     *         }
     *     }))
     */
    resolve<const Resolver extends Record<string, unknown>, const Type extends Exclude<LifeCycleType, 'scoped'>>(options: {
        as?: Type;
    }, resolver: (context: Prettify<Context<Metadata['schema'] & EphemeralMetadata['schema'], Singleton & EphemeralSingleton>>) => MaybePromise<Resolver>): Type extends 'global' ? Elysia<BasePath, Scoped, {
        decorator: Singleton['decorator'];
        store: Singleton['store'];
        derive: Singleton['resolve'];
        resolve: Prettify<Singleton['resolve'] & Awaited<Resolver>>;
    }, Definitions, Metadata, Routes, EphemeralSingleton, EphemeralMetadata> : Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes, {
        decorator: EphemeralSingleton['decorator'];
        store: EphemeralSingleton['store'];
        derive: EphemeralSingleton['resolve'];
        resolve: Prettify<EphemeralSingleton['resolve'] & Awaited<Resolver>>;
    }, EphemeralMetadata>;
    /**
     * Derive new property for each request with access to `Context`.
     *
     * If error is thrown, the scope will skip to handling error instead.
     *
     * ---
     * @example
     * new Elysia()
     *     .state('counter', 1)
     *     .derive(({ store }) => ({
     *         increase() {
     *             store.counter++
     *         }
     *     }))
     */
    resolve<const Resolver extends Record<string, unknown>>(resolver: (context: Prettify<Context<Metadata['schema'] & EphemeralMetadata['schema'], Singleton & EphemeralSingleton>>) => MaybePromise<Resolver>): Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes, {
        decorator: EphemeralSingleton['decorator'];
        store: EphemeralSingleton['store'];
        derive: EphemeralSingleton['derive'];
        resolve: Prettify<EphemeralSingleton['resolve'] & Awaited<Resolver>>;
    }, EphemeralMetadata>;
    mapResolve<const NewResolver extends Record<string, unknown>>(mapper: (context: Context<Metadata['schema'] & EphemeralMetadata['schema'], Singleton & EphemeralSingleton, BasePath>) => MaybePromise<NewResolver>): Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes, {
        decorator: EphemeralSingleton['decorator'];
        store: EphemeralSingleton['store'];
        derive: EphemeralSingleton['derive'];
        resolve: NewResolver;
    }, EphemeralMetadata>;
    mapResolve<const NewResolver extends Record<string, unknown>, const Type extends Exclude<LifeCycleType, 'scoped'>>(options: {
        as?: Type;
    }, mapper: (context: Context<Metadata['schema'] & EphemeralMetadata['schema'], Singleton & EphemeralSingleton, BasePath>) => MaybePromise<NewResolver>): Type extends 'global' ? Elysia<BasePath, Scoped, {
        decorator: Singleton['decorator'];
        store: Singleton['store'];
        derive: Singleton['derive'];
        resolve: NewResolver;
    }, Definitions, Metadata, Routes, EphemeralSingleton, EphemeralMetadata> : Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes, {
        decorator: EphemeralSingleton['decorator'];
        store: EphemeralSingleton['store'];
        derive: EphemeralSingleton['derive'];
        resolve: NewResolver;
    }, EphemeralMetadata>;
    /**
     * ### Before Handle | Life cycle event
     * Execute after validation and before the main route handler.
     *
     * If truthy value is returned, will be assigned as `Response` and skip the main handler
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onBeforeHandle(({ params: { id }, status }) => {
     *         if(id && !isExisted(id)) {
     * 	           status(401)
     *
     *             return "Unauthorized"
     * 	       }
     *     })
     * ```
     */
    onBeforeHandle<const Schema extends RouteSchema>(handler: MaybeArray<OptionalHandler<MergeSchema<Schema, Metadata['schema'] & EphemeralMetadata['schema']>, Singleton & EphemeralSingleton>>): this;
    /**
     * ### Before Handle | Life cycle event
     * Execute after validation and before the main route handler.
     *
     * If truthy value is returned, will be assigned as `Response` and skip the main handler
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onBeforeHandle(({ params: { id }, status }) => {
     *         if(id && !isExisted(id)) {
     * 	           status(401)
     *
     *             return "Unauthorized"
     * 	       }
     *     })
     * ```
     */
    onBeforeHandle<const Schema extends RouteSchema, const Type extends LifeCycleType>(options: {
        as?: Type;
    }, handler: MaybeArray<OptionalHandler<MergeSchema<Schema, Metadata['schema'] & EphemeralMetadata['schema']>, Singleton & ('global' extends Type ? Partial2<EphemeralSingleton> : EphemeralSingleton)>>): this;
    /**
     * ### After Handle | Life cycle event
     * Intercept request **after** main handler is called.
     *
     * If truthy value is returned, will be assigned as `Response`
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onAfterHandle((context, response) => {
     *         if(typeof response === "object")
     *             return JSON.stringify(response)
     *     })
     * ```
     */
    onAfterHandle<const Schema extends RouteSchema>(handler: MaybeArray<AfterHandler<MergeSchema<Schema, Metadata['schema'] & EphemeralMetadata['schema']>, Singleton & EphemeralSingleton>>): this;
    /**
     * ### After Handle | Life cycle event
     * Intercept request **after** main handler is called.
     *
     * If truthy value is returned, will be assigned as `Response`
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onAfterHandle((context, response) => {
     *         if(typeof response === "object")
     *             return JSON.stringify(response)
     *     })
     * ```
     */
    onAfterHandle<const Schema extends RouteSchema>(options: {
        as?: LifeCycleType;
    }, handler: MaybeArray<AfterHandler<MergeSchema<Schema, Metadata['schema'] & EphemeralMetadata['schema']>, Singleton & EphemeralSingleton>>): this;
    /**
     * ### After Handle | Life cycle event
     * Intercept request **after** main handler is called.
     *
     * If truthy value is returned, will be assigned as `Response`
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .mapResponse((context, response) => {
     *         if(typeof response === "object")
     *             return JSON.stringify(response)
     *     })
     * ```
     */
    mapResponse<const Schema extends RouteSchema>(handler: MaybeArray<MapResponse<MergeSchema<Schema, Metadata['schema'] & EphemeralMetadata['schema']>, Singleton & EphemeralSingleton>>): this;
    /**
     * ### After Handle | Life cycle event
     * Intercept request **after** main handler is called.
     *
     * If truthy value is returned, will be assigned as `Response`
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .mapResponse((context, response) => {
     *         if(typeof response === "object")
     *             return JSON.stringify(response)
     *     })
     * ```
     */
    mapResponse<const Schema extends RouteSchema>(options: {
        as?: LifeCycleType;
    }, handler: MaybeArray<MapResponse<MergeSchema<Schema, Metadata['schema'] & EphemeralMetadata['schema']>, Singleton & EphemeralSingleton>>): this;
    /**
     * ### response | Life cycle event
     * Called when handler is executed
     * Good for analytic metrics
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onError(({ code }) => {
     *         if(code === "NOT_FOUND")
     *             return "Path not found :("
     *     })
     * ```
     */
    onResponse<const Schema extends RouteSchema>(handler: MaybeArray<VoidHandler<MergeSchema<Schema, Metadata['schema'] & EphemeralMetadata['schema']>, Singleton & EphemeralSingleton>>): this;
    /**
     * ### response | Life cycle event
     * Called when handler is executed
     * Good for analytic metrics
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onError(({ code }) => {
     *         if(code === "NOT_FOUND")
     *             return "Path not found :("
     *     })
     * ```
     */
    onResponse<const Schema extends RouteSchema>(options: {
        as?: LifeCycleType;
    }, handler: MaybeArray<VoidHandler<MergeSchema<Schema, Metadata['schema'] & EphemeralMetadata['schema']>, Singleton & EphemeralSingleton>>): this;
    /**
     * ### After Handle | Life cycle event
     * Intercept request **after** main handler is called.
     *
     * If truthy value is returned, will be assigned as `Response`
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onAfterHandle((context, response) => {
     *         if(typeof response === "object")
     *             return JSON.stringify(response)
     *     })
     * ```
     */
    trace<const Schema extends RouteSchema>(handler: MaybeArray<TraceHandler<Schema, Singleton>>): this;
    /**
     * ### After Handle | Life cycle event
     * Intercept request **after** main handler is called.
     *
     * If truthy value is returned, will be assigned as `Response`
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onAfterHandle((context, response) => {
     *         if(typeof response === "object")
     *             return JSON.stringify(response)
     *     })
     * ```
     */
    trace<const Schema extends RouteSchema>(options: {
        as?: LifeCycleType;
    }, handler: MaybeArray<TraceHandler<Schema, Singleton>>): this;
    /**
     * Register errors
     *
     * ---
     * @example
     * ```typescript
     * class CustomError extends Error {
     *     constructor() {
     *         super()
     *     }
     * }
     *
     * new Elysia()
     *     .error('CUSTOM_ERROR', CustomError)
     * ```
     */
    error<const Errors extends Record<string, {
        prototype: Error;
    }>>(errors: Errors): Elysia<BasePath, Scoped, Singleton, {
        type: Definitions['type'];
        error: Definitions['error'] & {
            [K in keyof Errors]: Errors[K] extends {
                prototype: infer LiteralError extends Error;
            } ? LiteralError : Errors[K];
        };
    }, Metadata, Routes, EphemeralSingleton, EphemeralMetadata>;
    /**
     * Register errors
     *
     * ---
     * @example
     * ```typescript
     * class CustomError extends Error {
     *     constructor() {
     *         super()
     *     }
     * }
     *
     * new Elysia()
     *     .error({
     *         CUSTOM_ERROR: CustomError
     *     })
     * ```
     */
    error<Name extends string, const CustomError extends {
        prototype: Error;
    }>(name: Name, errors: CustomError): Elysia<BasePath, Scoped, Singleton, {
        type: Definitions['type'];
        error: Definitions['error'] & {
            [name in Name]: CustomError extends {
                prototype: infer LiteralError extends Error;
            } ? LiteralError : CustomError;
        };
    }, Metadata, Routes, EphemeralSingleton, EphemeralMetadata>;
    /**
     * Register errors
     *
     * ---
     * @example
     * ```typescript
     * class CustomError extends Error {
     *     constructor() {
     *         super()
     *     }
     * }
     *
     * new Elysia()
     *     .error('CUSTOM_ERROR', CustomError)
     * ```
     */
    error<const NewErrors extends Record<string, Error>>(mapper: (decorators: Definitions['error']) => NewErrors): Elysia<BasePath, Scoped, Singleton, {
        type: Definitions['type'];
        error: {
            [K in keyof NewErrors]: NewErrors[K] extends {
                prototype: infer LiteralError extends Error;
            } ? LiteralError : never;
        };
    }, Metadata, Routes, EphemeralSingleton, EphemeralMetadata>;
    /**
     * ### Error | Life cycle event
     * Called when error is thrown during processing request
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onError(({ code }) => {
     *         if(code === "NOT_FOUND")
     *             return "Path not found :("
     *     })
     * ```
     */
    onError<const Schema extends RouteSchema>(handler: ErrorHandler<Definitions['error'], MergeSchema<Schema, Metadata['schema'] | EphemeralMetadata['schema']>, Singleton>): this;
    /**
     * ### Error | Life cycle event
     * Called when error is thrown during processing request
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onError(({ code }) => {
     *         if(code === "NOT_FOUND")
     *             return "Path not found :("
     *     })
     * ```
     */
    onError<const Schema extends RouteSchema>(options: {
        as?: LifeCycleType;
    }, handler: ErrorHandler<Definitions['error'], MergeSchema<Schema, Metadata['schema'] | EphemeralMetadata['schema']>, Singleton>): this;
    /**
     * ### stop | Life cycle event
     * Called after server stop serving request
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .onStop((app) => {
     *         cleanup()
     *     })
     * ```
     */
    onStop(handler: MaybeArray<GracefulHandler<this>>): this;
    /**
     * ### on
     * Syntax sugar for attaching life cycle event by name
     *
     * Does the exact same thing as `.on[Event]()`
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .on('error', ({ code }) => {
     *         if(code === "NOT_FOUND")
     *             return "Path not found :("
     *     })
     * ```
     */
    on<Event extends keyof LifeCycleStore>(type: Exclude<Event, 'onResponse'> | 'response', handlers: MaybeArray<Extract<LifeCycleStore[Event], Function[]>[0]>): this;
    /**
     * ### on
     * Syntax sugar for attaching life cycle event by name
     *
     * Does the exact same thing as `.on[Event]()`
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .on('error', ({ code }) => {
     *         if(code === "NOT_FOUND")
     *             return "Path not found :("
     *     })
     * ```
     */
    on<const Event extends keyof LifeCycleStore>(options: {
        as?: LifeCycleType;
    }, type: Exclude<Event, 'onResponse'> | 'response', handlers: MaybeArray<Extract<LifeCycleStore[Event], Function[]>[0]>): this;
    group<const Prefix extends string, const NewElysia extends Elysia<any, any, any, any, any, any, any, any>>(prefix: Prefix, run: (group: Elysia<`${BasePath}${Prefix}`, Scoped, Singleton, Definitions, Metadata>) => NewElysia): Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Prettify<Routes & NewElysia['_routes']>, EphemeralSingleton, EphemeralMetadata>;
    group<const Prefix extends string, const NewElysia extends Elysia<any, any, any, any, any, any, any, any>, const Input extends InputSchema<Extract<keyof Definitions['type'], string>>, const Schema extends MergeSchema<UnwrapRoute<Input, Definitions['type']>, Metadata['schema']>>(prefix: Prefix, schema: LocalHook<Input, Schema, Singleton & EphemeralSingleton, Definitions['error'], Metadata['macro'] & EphemeralMetadata['macro'], `${BasePath}${Prefix}`>, run: (group: Elysia<`${BasePath}${Prefix}`, false, Singleton, Definitions, {
        schema: Schema;
        macro: Metadata['macro'];
    }, {}, EphemeralSingleton, EphemeralMetadata>) => NewElysia): Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes & NewElysia['_routes'], EphemeralSingleton, EphemeralMetadata>;
    guard<const LocalSchema extends InputSchema<Extract<keyof Definitions['type'], string>>, const Schema extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, Metadata['schema']>>(hook: LocalHook<LocalSchema, Schema, Singleton & EphemeralSingleton, Definitions['error'], Metadata['macro'] & EphemeralMetadata['macro'], BasePath>): Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes, EphemeralSingleton, {
        schema: MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, Metadata['schema'] & EphemeralMetadata['macro']>;
        macro: EphemeralMetadata['macro'];
    }>;
    guard<const LocalSchema extends InputSchema<Extract<keyof Definitions['type'], string>>, const NewElysia extends Elysia<any, any, any, any, any, any, any, any>, const Schema extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, Metadata['schema']>>(run: (group: Elysia<BasePath, Scoped, Singleton, Definitions, {
        schema: Prettify<Schema>;
        macro: Metadata['macro'];
    }, {}, EphemeralSingleton, EphemeralMetadata>) => NewElysia): Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Prettify<Routes & NewElysia['_routes']>, EphemeralSingleton, EphemeralMetadata>;
    guard<const LocalSchema extends InputSchema<Extract<keyof Definitions['type'], string>>, const NewElysia extends Elysia<any, any, any, any, any, any, any, any>, const Schema extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, Metadata['schema']>>(schema: LocalHook<LocalSchema, Schema, Singleton & EphemeralSingleton, Definitions['error'], Metadata['macro'] & EphemeralMetadata['macro'], ''>, run: (group: Elysia<BasePath, Scoped, Singleton, Definitions, {
        schema: Prettify<Schema>;
        macro: Metadata['macro'];
    }, {}, EphemeralSingleton, EphemeralMetadata>) => NewElysia): Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Prettify<Routes & NewElysia['_routes']>, EphemeralSingleton, EphemeralMetadata>;
    /**
     * Inline fn
     */
    use<const NewElysia extends Elysia<any, any, any, any, any, any, any, any>, const Scoped extends boolean = false, const Param extends Elysia<any, any, any, any, any, any, any, any> = this>(plugin: MaybePromise<(app: Param) => MaybePromise<NewElysia>>, options?: {
        scoped?: Scoped;
    }): Scoped extends true ? Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes & NewElysia['_routes']> : Elysia<BasePath, Scoped, Prettify2<Singleton & NewElysia['_types']['Singleton']>, Prettify2<Definitions & NewElysia['_types']['Definitions']>, Prettify2<Metadata & NewElysia['_types']['Metadata']>, Routes & NewElysia['_routes']>;
    /**
     * Inline Fn with scoped
     **/
    use<const NewElysia extends Elysia<any, any, any, any, any, any, any, any>, const Scoped extends boolean = false, const Params extends Elysia<any, any, any, any, any, any, any, any> = this>(plugin: MaybePromise<(app: Params) => MaybePromise<NewElysia>>, options?: {
        scoped?: Scoped;
    }): Scoped extends true ? Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes & NewElysia['_routes']> : Elysia<BasePath, Scoped, Prettify2<Singleton & NewElysia['_types']['Singleton']>, Prettify2<Definitions & NewElysia['_types']['Definitions']>, Prettify2<Metadata & NewElysia['_types']['Metadata']>, Routes & NewElysia['_routes']>;
    /**
     * Entire Instance where scoped is true
     **/
    use<const NewElysia extends Elysia<any, true, any, any, any, any, any, any>>(instance: MaybePromise<NewElysia>, options?: {
        scoped?: boolean;
    }): Elysia<BasePath, true, Prettify2<Singleton & NewElysia['_types']['Singleton']>, Definitions, Metadata, Routes extends `` ? Routes & NewElysia['_routes'] : Routes & CreateEden<BasePath, NewElysia['_routes']>>;
    /**
     * Entire Instance where scoped is false
     **/
    use<const NewElysia extends Elysia<any, false, any, any, any, any, any, any>, const Scoped extends boolean = false>(instance: MaybePromise<NewElysia>, options?: {
        scoped?: Scoped;
    }): Scoped extends true ? Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes & NewElysia['_routes']> : Elysia<BasePath, Scoped, Prettify2<Singleton & NewElysia['_types']['Singleton']>, Prettify2<Definitions & NewElysia['_types']['Definitions']>, Prettify2<Metadata & NewElysia['_types']['Metadata']>, BasePath extends `` ? Routes & NewElysia['_routes'] : Routes & CreateEden<BasePath, NewElysia['_routes']>>;
    /**
     * Import fn
     */
    use<const NewElysia extends Elysia<any, any, any, any, any, any, any, any>, const Scoped extends boolean = false>(plugin: Promise<{
        default: (elysia: Elysia<any, any, any, any, any, any, any, any>) => MaybePromise<NewElysia>;
    }>, options?: {
        scoped?: Scoped;
    }): Scoped extends true ? Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes & NewElysia['_routes']> : Elysia<BasePath, Scoped, Prettify2<Singleton & NewElysia['_types']['Singleton']>, Prettify2<Definitions & NewElysia['_types']['Definitions']>, Prettify2<Metadata & NewElysia['_types']['Metadata']>, BasePath extends `` ? Routes & NewElysia['_routes'] : Routes & CreateEden<BasePath, NewElysia['_routes']>>;
    /**
     * Import entire instance
     */
    use<const LazyLoadElysia extends Elysia<any, any, any, any, any, any, any, any>, const Type extends LifeCycleType>(plugin: Promise<{
        default: LazyLoadElysia;
    }>, options?: {
        scoped?: boolean;
    }): Type extends 'global' ? Elysia<BasePath, Scoped, Prettify2<Singleton & LazyLoadElysia['_types']['Singleton']>, Prettify2<Definitions & LazyLoadElysia['_types']['Definitions']>, Prettify2<Metadata & LazyLoadElysia['_types']['Metadata']>, BasePath extends `` ? Routes & LazyLoadElysia['_routes'] : Routes & CreateEden<BasePath, LazyLoadElysia['_routes']>> : Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Prettify<Routes & LazyLoadElysia['_routes']>>;
    private _use;
    macro<const NewMacro extends BaseMacro>(macro: (route: MacroManager<Metadata['schema'] & EphemeralMetadata['schema'], Singleton & EphemeralSingleton, Definitions['error']>) => NewMacro): Elysia<BasePath, Scoped, Singleton, Definitions, {
        schema: Metadata['schema'];
        macro: Metadata['macro'] & Partial<MacroToProperty<NewMacro>>;
    }, Routes, EphemeralSingleton, EphemeralMetadata>;
    mount(handle: ((request: Request) => MaybePromise<Response>) | Elysia<any, any, any, any, any, any, any, any>): this;
    mount(path: string, handle: ((request: Request) => MaybePromise<Response>) | Elysia<any, any, any, any, any, any, any, any>): this;
    /**
     * ### get
     * Register handler for path with method [GET]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .get('/', () => 'hi')
     *     .get('/with-hook', () => 'hi', {
     *         response: t.String()
     *     })
     * ```
     */
    get<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, Metadata['schema'] & EphemeralMetadata['schema']>, const Handle extends InlineHandler<Schema, Singleton & EphemeralSingleton, `${BasePath}${Path extends '/' ? '' : Path}`>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Schema, Singleton & EphemeralSingleton, Definitions['error'], Metadata['macro'] & EphemeralMetadata['macro'], `${BasePath}${Path extends '/' ? '/index' : Path}`>): Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes & CreateEden<`${BasePath & string}${Path extends '/' ? '/index' : Path}`, {
        get: {
            body: Schema['body'];
            params: undefined extends Schema['params'] ? Record<GetPathParameter<Path>, string> : Schema['params'];
            query: Schema['query'];
            headers: Schema['headers'];
            response: ComposeElysiaResponse<Schema['response'], Handle>;
        };
    }>, EphemeralSingleton, EphemeralMetadata>;
    /**
     * ### post
     * Register handler for path with method [POST]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .post('/', () => 'hi')
     *     .post('/with-hook', () => 'hi', {
     *         response: t.String()
     *     })
     * ```
     */
    post<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, Metadata['schema'] & EphemeralMetadata['schema']>, const Handle extends InlineHandler<Schema, Singleton & EphemeralSingleton, `${BasePath}${Path extends '/' ? '/index' : Path}`>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Schema, Singleton & EphemeralSingleton, Definitions['error'], Metadata['macro'] & EphemeralMetadata['macro'], `${BasePath}${Path extends '/' ? '/index' : Path}`>): Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes & CreateEden<`${BasePath & string}${Path extends '/' ? '/index' : Path}`, {
        post: {
            body: Schema['body'];
            params: undefined extends Schema['params'] ? Record<GetPathParameter<Path>, string> : Schema['params'];
            query: Schema['query'];
            headers: Schema['headers'];
            response: ComposeElysiaResponse<Schema['response'], Handle>;
        };
    }>, EphemeralSingleton, EphemeralMetadata>;
    /**
     * ### put
     * Register handler for path with method [PUT]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .put('/', () => 'hi')
     *     .put('/with-hook', () => 'hi', {
     *         response: t.String()
     *     })
     * ```
     */
    put<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, Metadata['schema'] & EphemeralMetadata['schema']>, const Handle extends InlineHandler<Schema, Singleton & EphemeralSingleton, `${BasePath}${Path extends '/' ? '/index' : Path}`>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Schema, Singleton & EphemeralSingleton, Definitions['error'], Metadata['macro'] & EphemeralMetadata['macro'], `${BasePath}${Path extends '/' ? '/index' : Path}`>): Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes & CreateEden<`${BasePath & string}${Path extends '/' ? '/index' : Path}`, {
        put: {
            body: Schema['body'];
            params: undefined extends Schema['params'] ? Record<GetPathParameter<Path>, string> : Schema['params'];
            query: Schema['query'];
            headers: Schema['headers'];
            response: ComposeElysiaResponse<Schema['response'], Handle>;
        };
    }>, EphemeralSingleton, EphemeralMetadata>;
    /**
     * ### patch
     * Register handler for path with method [PATCH]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .patch('/', () => 'hi')
     *     .patch('/with-hook', () => 'hi', {
     *         response: t.String()
     *     })
     * ```
     */
    patch<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, Metadata['schema'] & EphemeralMetadata['schema']>, const Handle extends InlineHandler<Schema, Singleton & EphemeralSingleton, `${BasePath}${Path extends '/' ? '/index' : Path}`>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Schema, Singleton & EphemeralSingleton, Definitions['error'], Metadata['macro'] & EphemeralMetadata['macro'], `${BasePath}${Path extends '/' ? '/index' : Path}`>): Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes & CreateEden<`${BasePath & string}${Path extends '/' ? '/index' : Path}`, {
        patch: {
            body: Schema['body'];
            params: undefined extends Schema['params'] ? Record<GetPathParameter<Path>, string> : Schema['params'];
            query: Schema['query'];
            headers: Schema['headers'];
            response: ComposeElysiaResponse<Schema['response'], Handle>;
        };
    }>, EphemeralSingleton, EphemeralMetadata>;
    /**
     * ### delete
     * Register handler for path with method [DELETE]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .delete('/', () => 'hi')
     *     .delete('/with-hook', () => 'hi', {
     *         response: t.String()
     *     })
     * ```
     */
    delete<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, Metadata['schema'] & EphemeralMetadata['schema']>, const Handle extends InlineHandler<Schema, Singleton & EphemeralSingleton, `${BasePath}${Path extends '/' ? '/index' : Path}`>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Schema, Singleton & EphemeralSingleton, Definitions['error'], Metadata['macro'] & EphemeralMetadata['macro'], `${BasePath}${Path extends '/' ? '/index' : Path}`>): Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes & CreateEden<`${BasePath & string}${Path extends '/' ? '/index' : Path}`, {
        delete: {
            body: Schema['body'];
            params: undefined extends Schema['params'] ? Record<GetPathParameter<Path>, string> : Schema['params'];
            query: Schema['query'];
            headers: Schema['headers'];
            response: ComposeElysiaResponse<Schema['response'], Handle>;
        };
    }>, EphemeralSingleton, EphemeralMetadata>;
    /**
     * ### options
     * Register handler for path with method [POST]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .options('/', () => 'hi')
     *     .options('/with-hook', () => 'hi', {
     *         response: t.String()
     *     })
     * ```
     */
    options<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, Metadata['schema'] & EphemeralMetadata['schema']>, const Handle extends InlineHandler<Schema, Singleton & EphemeralSingleton, `${BasePath}${Path extends '/' ? '/index' : Path}`>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Schema, Singleton & EphemeralSingleton, Definitions['error'], Metadata['macro'] & EphemeralMetadata['macro'], `${BasePath}${Path extends '/' ? '/index' : Path}`>): Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes & CreateEden<`${BasePath & string}${Path extends '/' ? '/index' : Path}`, {
        options: {
            body: Schema['body'];
            params: undefined extends Schema['params'] ? Record<GetPathParameter<Path>, string> : Schema['params'];
            query: Schema['query'];
            headers: Schema['headers'];
            response: ComposeElysiaResponse<Schema['response'], Handle>;
        };
    }>, EphemeralSingleton, EphemeralMetadata>;
    /**
     * ### all
     * Register handler for path with method [ALL]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .all('/', () => 'hi')
     *     .all('/with-hook', () => 'hi', {
     *         response: t.String()
     *     })
     * ```
     */
    all<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, Metadata['schema'] & EphemeralMetadata['schema']>, const Handle extends InlineHandler<Schema, Singleton & EphemeralSingleton, `${BasePath}${Path extends '/' ? '/index' : Path}`>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Schema, Singleton & EphemeralSingleton, Definitions['error'], Metadata['macro'] & EphemeralMetadata['macro'], `${BasePath}${Path extends '/' ? '/index' : Path}`>): Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes & CreateEden<`${BasePath & string}${Path extends '/' ? '/index' : Path}`, {
        [method in string]: {
            body: Schema['body'];
            params: undefined extends Schema['params'] ? Record<GetPathParameter<Path>, string> : Schema['params'];
            query: Schema['query'];
            headers: Schema['headers'];
            response: ComposeElysiaResponse<Schema['response'], Handle>;
        };
    }>, EphemeralSingleton, EphemeralMetadata>;
    /**
     * ### head
     * Register handler for path with method [HEAD]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .head('/', () => 'hi')
     *     .head('/with-hook', () => 'hi', {
     *         response: t.String()
     *     })
     * ```
     */
    head<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, Metadata['schema'] & EphemeralMetadata['schema']>, const Handle extends InlineHandler<Schema, Singleton & EphemeralSingleton, `${BasePath}${Path extends '/' ? '/index' : Path}`>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Schema, Singleton & EphemeralSingleton, Definitions['error'], Metadata['macro'] & EphemeralMetadata['macro'], `${BasePath}${Path extends '/' ? '/index' : Path}`>): Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes & CreateEden<`${BasePath & string}${Path extends '/' ? '/index' : Path}`, {
        head: {
            body: Schema['body'];
            params: undefined extends Schema['params'] ? Record<GetPathParameter<Path>, string> : Schema['params'];
            query: Schema['query'];
            headers: Schema['headers'];
            response: ComposeElysiaResponse<Schema['response'], Handle>;
        };
    }>, EphemeralSingleton, EphemeralMetadata>;
    /**
     * ### connect
     * Register handler for path with method [CONNECT]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .connect('/', () => 'hi')
     *     .connect('/with-hook', () => 'hi', {
     *         response: t.String()
     *     })
     * ```
     */
    connect<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, Metadata['schema'] & EphemeralMetadata['schema']>, const Handle extends InlineHandler<Schema, Singleton & EphemeralSingleton, `${BasePath}${Path extends '/' ? '/index' : Path}`>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Schema, Singleton & EphemeralSingleton, Definitions['error'], Metadata['macro'] & EphemeralMetadata['macro'], `${BasePath}${Path extends '/' ? '/index' : Path}`>): Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes & CreateEden<`${BasePath & string}${Path extends '/' ? '/index' : Path}`, {
        connect: {
            body: Schema['body'];
            params: undefined extends Schema['params'] ? Record<GetPathParameter<Path>, string> : Schema['params'];
            query: Schema['query'];
            headers: Schema['headers'];
            response: ComposeElysiaResponse<Schema['response'], Handle>;
        };
    }>, EphemeralSingleton, EphemeralMetadata>;
    /**
     * ### route
     * Register handler for path with method [ROUTE]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .route('/', () => 'hi')
     *     .route('/with-hook', () => 'hi', {
     *         response: t.String()
     *     })
     * ```
     */
    route<const Method extends HTTPMethod, const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, Metadata['schema'] & EphemeralMetadata['schema']>, const Handle extends InlineHandler<Schema, Singleton & EphemeralSingleton, `${BasePath}${Path extends '/' ? '/index' : Path}`>>(method: Method, path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Schema, Singleton & EphemeralSingleton, Definitions['error'], Metadata['macro'] & EphemeralMetadata['macro'], `${BasePath}${Path extends '/' ? '/index' : Path}`> & {
        config: {
            allowMeta?: boolean;
        };
    }): Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes & CreateEden<`${BasePath & string}${Path extends '/' ? '/index' : Path}`, {
        [method in Method]: {
            body: Schema['body'];
            params: undefined extends Schema['params'] ? Record<GetPathParameter<Path>, string> : Schema['params'];
            query: Schema['query'];
            headers: Schema['headers'];
            response: ComposeElysiaResponse<Schema['response'], Handle>;
        };
    }>, EphemeralSingleton, EphemeralMetadata>;
    /**
     * ### ws
     * Register handler for path with method [ws]
     *
     * ---
     * @example
     * ```typescript
     * import { Elysia, t } from 'elysia'
     *
     * new Elysia()
     *     .ws('/', {
     *         message(ws, message) {
     *             ws.send(message)
     *         }
     *     })
     * ```
     */
    ws<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends MergeSchema<UnwrapRoute<LocalSchema, Definitions['type']>, Metadata['schema']>>(path: Path, options: WS.LocalHook<LocalSchema, Schema, Singleton & EphemeralSingleton, Definitions['error'], Metadata['macro'] & EphemeralMetadata['macro'], `${BasePath}${Path extends '/' ? '/index' : Path}`>): Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes & CreateEden<`${BasePath}${Path extends '/' ? '/index' : Path}`, {
        subscribe: {
            body: Schema['body'];
            params: undefined extends Schema['params'] ? Record<GetPathParameter<Path>, string> : Schema['params'];
            query: Schema['query'];
            headers: Schema['headers'];
            response: Schema['response'];
        };
    }>, EphemeralSingleton, EphemeralMetadata>;
    /**
     * ### state
     * Assign global mutatable state accessible for all handler
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .state({ counter: 0 })
     *     .get('/', (({ counter }) => ++counter)
     * ```
     */
    state<const Name extends string | number | symbol, Value>(name: Name, value: Value): Scoped extends true ? Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes, {
        decorator: EphemeralSingleton['decorator'];
        store: Prettify<EphemeralSingleton['store'] & {
            [name in Name]: Value;
        }>;
        derive: EphemeralSingleton['derive'];
        resolve: EphemeralSingleton['resolve'];
    }, EphemeralMetadata> : Elysia<BasePath, Scoped, {
        decorator: Singleton['decorator'];
        store: Prettify<Singleton['store'] & {
            [name in Name]: Value;
        }>;
        derive: Singleton['derive'];
        resolve: Singleton['resolve'];
    }, Definitions, Metadata, Routes, EphemeralSingleton, EphemeralMetadata>;
    /**
     * ### state
     * Assign global mutatable state accessible for all handler
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .state('counter', 0)
     *     .get('/', (({ counter }) => ++counter)
     * ```
     */
    state<Store extends Record<string, unknown>>(store: Store): Scoped extends true ? Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes, {
        decorator: EphemeralSingleton['decorator'];
        store: Prettify<EphemeralSingleton['store'] & Store>;
        derive: EphemeralSingleton['derive'];
        resolve: EphemeralSingleton['resolve'];
    }, EphemeralMetadata> : Elysia<BasePath, Scoped, {
        decorator: Singleton['decorator'];
        store: Prettify<Singleton['store'] & Store>;
        derive: Singleton['derive'];
        resolve: Singleton['resolve'];
    }, Definitions, Metadata, Routes, EphemeralSingleton, EphemeralMetadata>;
    state<NewStore extends Record<string, unknown>>(mapper: (decorators: Singleton['store'] & EphemeralSingleton['store']) => NewStore): Scoped extends true ? Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes, {
        decorator: EphemeralSingleton['decorator'];
        store: NewStore;
        derive: EphemeralSingleton['derive'];
        resolve: EphemeralSingleton['resolve'];
    }, EphemeralMetadata> : Elysia<BasePath, Scoped, {
        decorator: Singleton['decorator'];
        store: NewStore;
        derive: Singleton['derive'];
        resolve: Singleton['resolve'];
    }, Definitions, Metadata, Routes, EphemeralSingleton, EphemeralMetadata>;
    /**
     * ### decorate
     * Define custom method to `Context` accessible for all handler
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .decorate('getDate', () => Date.now())
     *     .get('/', (({ getDate }) => getDate())
     * ```
     */
    decorate<const Name extends string, const Value>(name: Name, value: Value): Scoped extends true ? Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes, {
        decorator: Prettify<EphemeralSingleton['decorator'] & {
            [name in Name]: Value;
        }>;
        store: EphemeralSingleton['store'];
        derive: EphemeralSingleton['derive'];
        resolve: EphemeralSingleton['resolve'];
    }, EphemeralMetadata> : Elysia<BasePath, Scoped, {
        decorator: Prettify<Singleton['decorator'] & {
            [name in Name]: Value;
        }>;
        store: Singleton['store'];
        derive: Singleton['derive'];
        resolve: Singleton['resolve'];
    }, Definitions, Metadata, Routes, EphemeralSingleton, EphemeralMetadata>;
    /**
     * ### decorate
     * Define custom method to `Context` accessible for all handler
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .decorate('getDate', () => Date.now())
     *     .get('/', (({ getDate }) => getDate())
     * ```
     */
    decorate<const NewDecorators extends Record<string, unknown>>(decorators: NewDecorators): Scoped extends true ? Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes, {
        decorator: Prettify<EphemeralSingleton['decorator'] & NewDecorators>;
        store: EphemeralSingleton['store'];
        derive: EphemeralSingleton['derive'];
        resolve: EphemeralSingleton['resolve'];
    }, EphemeralMetadata> : Elysia<BasePath, Scoped, {
        decorator: Prettify<Singleton['decorator'] & NewDecorators>;
        store: Singleton['store'];
        derive: Singleton['derive'];
        resolve: Singleton['resolve'];
    }, Definitions, Metadata, Routes, EphemeralSingleton, EphemeralMetadata>;
    decorate<const NewDecorators extends Record<string, unknown>>(mapper: (decorators: Singleton['decorator'] & EphemeralSingleton['decorator']) => NewDecorators): Scoped extends true ? Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes, {
        decorator: NewDecorators;
        store: EphemeralSingleton['store'];
        derive: EphemeralSingleton['derive'];
        resolve: EphemeralSingleton['resolve'];
    }, EphemeralMetadata> : Elysia<BasePath, Scoped, {
        decorator: NewDecorators;
        store: Singleton['store'];
        derive: Singleton['derive'];
        resolve: Singleton['resolve'];
    }, Definitions, Metadata, Routes, EphemeralSingleton, EphemeralMetadata>;
    /**
     * Derive new property for each request with access to `Context`.
     *
     * If error is thrown, the scope will skip to handling error instead.
     *
     * ---
     * @example
     * new Elysia()
     *     .state('counter', 1)
     *     .derive(({ store }) => ({
     *         increase() {
     *             store.counter++
     *         }
     *     }))
     */
    derive<const Derivative extends Record<string, unknown>>(transform: (context: Prettify<Context<Metadata['schema'] & EphemeralMetadata['schema'], Singleton & EphemeralSingleton>>) => MaybePromise<Derivative>): Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes, {
        decorator: EphemeralSingleton['decorator'];
        store: EphemeralSingleton['store'];
        derive: Prettify<EphemeralSingleton['derive'] & Awaited<Derivative>>;
        resolve: EphemeralSingleton['resolve'];
    }, EphemeralMetadata>;
    /**
     * Derive new property for each request with access to `Context`.
     *
     * If error is thrown, the scope will skip to handling error instead.
     *
     * ---
     * @example
     * new Elysia()
     *     .state('counter', 1)
     *     .derive(({ store }) => ({
     *         increase() {
     *             store.counter++
     *         }
     *     }))
     */
    derive<const Derivative extends Record<string, unknown>, const Type extends Exclude<LifeCycleType, 'scoped'>>(options: {
        as?: Type;
    }, transform: (context: Prettify<Context<Metadata['schema'] & EphemeralMetadata['schema'], Singleton & EphemeralSingleton>>) => MaybePromise<Derivative>): Type extends 'global' ? Elysia<BasePath, Scoped, {
        decorator: Singleton['decorator'];
        store: Singleton['store'];
        derive: Prettify<Singleton['derive'] & Awaited<Derivative>>;
        resolve: Singleton['resolve'];
    }, Definitions, Metadata, Routes, EphemeralSingleton, EphemeralMetadata> : Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes, {
        decorator: EphemeralSingleton['decorator'];
        store: EphemeralSingleton['store'];
        derive: Prettify<EphemeralSingleton['derive'] & Awaited<Derivative>>;
        resolve: EphemeralSingleton['resolve'];
    }, EphemeralMetadata>;
    model<const Name extends string, const Model extends TSchema>(name: Name, model: Model): Elysia<BasePath, Scoped, Singleton, {
        type: Prettify<Definitions['type'] & {
            [name in Name]: Static<Model>;
        }>;
        error: Definitions['error'];
    }, Metadata, Routes, EphemeralSingleton, EphemeralMetadata>;
    model<const Recorder extends Record<string, TSchema>>(record: Recorder): Elysia<BasePath, Scoped, Singleton, {
        type: Prettify<Definitions['type'] & {
            [key in keyof Recorder]: Static<Recorder[key]>;
        }>;
        error: Definitions['error'];
    }, Metadata, Routes, EphemeralSingleton, EphemeralMetadata>;
    model<const NewType extends Record<string, TSchema>>(mapper: (decorators: {
        [type in keyof Definitions['type']]: ReturnType<typeof t.Unsafe<Definitions['type'][type]>>;
    }) => NewType): Elysia<BasePath, Scoped, Singleton, {
        type: {
            [x in keyof NewType]: Static<NewType[x]>;
        };
        error: Definitions['error'];
    }, Metadata, Routes, EphemeralSingleton, EphemeralMetadata>;
    mapDerive<const NewDerivative extends Record<string, unknown>>(mapper: (context: Context<Metadata['schema'] & EphemeralMetadata['schema'], Singleton & EphemeralSingleton, BasePath>) => MaybePromise<NewDerivative>): Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes, {
        decorator: EphemeralSingleton['decorator'];
        store: EphemeralSingleton['store'];
        derive: NewDerivative;
        resolve: EphemeralSingleton['resolve'];
    }, EphemeralMetadata>;
    mapDerive<const NewDerivative extends Record<string, unknown>, const Type extends Exclude<LifeCycleType, 'scoped'>>(options: {
        as?: Type;
    }, mapper: (context: Context<Metadata['schema'] & EphemeralMetadata['schema'], Singleton & EphemeralSingleton, BasePath>) => MaybePromise<NewDerivative>): Type extends 'global' ? Elysia<BasePath, Scoped, {
        decorator: Singleton['decorator'];
        store: Singleton['store'];
        derive: NewDerivative;
        resolve: Singleton['resolve'];
    }, Definitions, Metadata, Routes, EphemeralSingleton, EphemeralMetadata> : Elysia<BasePath, Scoped, Singleton, Definitions, Metadata, Routes, {
        decorator: EphemeralSingleton['decorator'];
        store: EphemeralSingleton['store'];
        derive: NewDerivative;
        resolve: EphemeralSingleton['resolve'];
    }, EphemeralMetadata>;
    affix<const Base extends 'prefix' | 'suffix', const Type extends 'all' | 'decorator' | 'state' | 'model' | 'error', const Word extends string>(base: Base, type: Type, word: Word): Elysia<BasePath, Scoped, {
        decorator: Type extends 'decorator' | 'all' ? 'prefix' extends Base ? Word extends `${string}${'_' | '-' | ' '}` ? AddPrefix<Word, Singleton['decorator']> : AddPrefixCapitalize<Word, Singleton['decorator']> : AddSuffixCapitalize<Word, Singleton['decorator']> : Singleton['decorator'];
        store: Type extends 'state' | 'all' ? 'prefix' extends Base ? Word extends `${string}${'_' | '-' | ' '}` ? AddPrefix<Word, Singleton['store']> : AddPrefixCapitalize<Word, Singleton['store']> : AddSuffix<Word, Singleton['store']> : Singleton['store'];
        derive: Type extends 'decorator' | 'all' ? 'prefix' extends Base ? Word extends `${string}${'_' | '-' | ' '}` ? AddPrefix<Word, Singleton['derive']> : AddPrefixCapitalize<Word, Singleton['derive']> : AddSuffixCapitalize<Word, Singleton['derive']> : Singleton['derive'];
        resolve: Type extends 'decorator' | 'all' ? 'prefix' extends Base ? Word extends `${string}${'_' | '-' | ' '}` ? AddPrefix<Word, Singleton['resolve']> : AddPrefixCapitalize<Word, Singleton['resolve']> : AddSuffixCapitalize<Word, Singleton['resolve']> : Singleton['resolve'];
    }, {
        type: Type extends 'model' | 'all' ? 'prefix' extends Base ? Word extends `${string}${'_' | '-' | ' '}` ? AddPrefix<Word, Definitions['type']> : AddPrefixCapitalize<Word, Definitions['type']> : AddSuffixCapitalize<Word, Definitions['type']> : Definitions['type'];
        error: Type extends 'error' | 'all' ? 'prefix' extends Base ? Word extends `${string}${'_' | '-' | ' '}` ? AddPrefix<Word, Definitions['error']> : AddPrefixCapitalize<Word, Definitions['error']> : AddSuffixCapitalize<Word, Definitions['error']> : Definitions['error'];
    }, Metadata, Routes, EphemeralSingleton, EphemeralMetadata>;
    prefix<const Type extends 'all' | 'decorator' | 'state' | 'model' | 'error', const Word extends string>(type: Type, word: Word): Elysia<BasePath, Scoped, {
        decorator: Type extends "decorator" | "all" ? Word extends `${string} ` | `${string}_` | `${string}-` ? AddPrefix<Word, Singleton["decorator"]> : AddPrefixCapitalize<Word, Singleton["decorator"]> : Singleton["decorator"];
        store: Type extends "all" | "state" ? Word extends `${string} ` | `${string}_` | `${string}-` ? AddPrefix<Word, Singleton["store"]> : AddPrefixCapitalize<Word, Singleton["store"]> : Singleton["store"];
        derive: Type extends "decorator" | "all" ? Word extends `${string} ` | `${string}_` | `${string}-` ? AddPrefix<Word, Singleton["derive"]> : AddPrefixCapitalize<Word, Singleton["derive"]> : Singleton["derive"];
        resolve: Type extends "decorator" | "all" ? Word extends `${string} ` | `${string}_` | `${string}-` ? AddPrefix<Word, Singleton["resolve"]> : AddPrefixCapitalize<Word, Singleton["resolve"]> : Singleton["resolve"];
    }, {
        type: Type extends "all" | "model" ? Word extends `${string} ` | `${string}_` | `${string}-` ? AddPrefix<Word, Definitions["type"]> : AddPrefixCapitalize<Word, Definitions["type"]> : Definitions["type"];
        error: Type extends "error" | "all" ? Word extends `${string} ` | `${string}_` | `${string}-` ? AddPrefix<Word, Definitions["error"]> : AddPrefixCapitalize<Word, Definitions["error"]> : Definitions["error"];
    }, Metadata, Routes, EphemeralSingleton, EphemeralMetadata>;
    suffix<const Type extends 'all' | 'decorator' | 'state' | 'model' | 'error', const Word extends string>(type: Type, word: Word): Elysia<BasePath, Scoped, {
        decorator: Type extends "decorator" | "all" ? AddSuffixCapitalize<Word, Singleton["decorator"]> : Singleton["decorator"];
        store: Type extends "all" | "state" ? AddSuffix<Word, Singleton["store"]> : Singleton["store"];
        derive: Type extends "decorator" | "all" ? AddSuffixCapitalize<Word, Singleton["derive"]> : Singleton["derive"];
        resolve: Type extends "decorator" | "all" ? AddSuffixCapitalize<Word, Singleton["resolve"]> : Singleton["resolve"];
    }, {
        type: Type extends "all" | "model" ? AddSuffixCapitalize<Word, Definitions["type"]> : Definitions["type"];
        error: Type extends "error" | "all" ? AddSuffixCapitalize<Word, Definitions["error"]> : Definitions["error"];
    }, Metadata, Routes, EphemeralSingleton, EphemeralMetadata>;
    compile(): this;
    handle: (request: Request) => Promise<Response>;
    /**
     * Use handle can be either sync or async to save performance.
     *
     * Beside benchmark purpose, please use 'handle' instead.
     */
    fetch: (request: Request) => MaybePromise<Response>;
    private handleError;
    private outerErrorHandler;
    /**
     * ### listen
     * Assign current instance to port and start serving
     *
     * ---
     * @example
     * ```typescript
     * new Elysia()
     *     .get("/", () => 'hi')
     *     .listen(8080)
     * ```
     */
    listen: (options: string | number | Partial<Serve>, callback?: ListenCallback) => this;
    /**
     * ### stop
     * Stop server from serving
     *
     * ---
     * @example
     * ```typescript
     * const app = new Elysia()
     *     .get("/", () => 'hi')
     *     .listen(8080)
     *
     * // Sometime later
     * app.stop()
     * ```
     */
    stop: () => Promise<void>;
    /**
     * Wait until all lazy loaded modules all load is fully
     */
    get modules(): Promise<Elysia<any, any, any, any, any, any, any, any>[]>;
}

type DynamicHandler = {
    handle: Handler<any, any>;
    content?: string;
    hooks: LifeCycleStore;
    validator?: SchemaValidator;
};
declare const createDynamicHandler: (app: Elysia<any, any, any, any, any, any, any, any>) => (request: Request) => Promise<Response>;
declare const createDynamicErrorHandler: (app: Elysia<any, any, any, any, any, any, any, any>) => (context: Context, error: ElysiaErrors) => Promise<Response>;

export { type AddPrefixCapitalize as $, type AfterHandler as A, type TraceProcess as B, type ComposedHandler as C, type DefinitionBase as D, Elysia as E, type TraceListener as F, type GetPathParameter as G, type Handler as H, type InputSchema as I, type BodyHandler as J, type PreHandler as K, type LifeCycleStore as L, type MaybeArray as M, type GracefulHandler as N, type ObjectValues as O, type Prettify as P, type ErrorHandler as Q, type Reconcile as R, type SchemaValidator as S, type TraceHandler as T, type UnwrapSchema as U, type VoidHandler as V, type Isolate as W, type LocalHook as X, type InternalRoute as Y, type ListenCallback as Z, type AddPrefix as _, type TraceReporter as a, type AddSuffix as a0, type AddSuffixCapitalize as a1, type Checksum as a2, type BaseMacro as a3, type MacroToProperty as a4, type ElysiaFn as a5, type MacroManager as a6, type MacroQueue as a7, type CreateEden as a8, type ComposeElysiaResponse as a9, ElysiaType as aA, type TCookie as aB, websocket as aC, ElysiaWS as aD, WS as aE, isNotEmpty as aF, parseSetCookies as aG, serializeCookie as aH, mapResponse as aI, mapEarlyResponse as aJ, mapCompactResponse as aK, errorToResponse as aL, type DynamicHandler as aM, createDynamicHandler as aN, createDynamicErrorHandler as aO, type MergeElysiaInstances as aa, type LifeCycleType as ab, replaceUrlPath as ac, mergeDeep as ad, mergeCookie as ae, mergeObjectArray as af, primitiveHooks as ag, mergeHook as ah, getSchemaValidator as ai, getResponseSchemaValidator as aj, checksum as ak, getCookieValidator as al, mergeLifeCycle as am, asHookType as an, filterGlobalHook as ao, StatusMap as ap, InvertedStatusMap as aq, signCookie as ar, unsignCookie as as, traceBackMacro as at, createMacroManager as au, isNumericString as av, type Context as aw, type PreContext as ax, t as ay, ElysiaTypeOptions as az, type TraceStream as b, type CookieOptions as c, type ElysiaCookie as d, Cookie as e, createCookieJar as f, type ElysiaConfig as g, type MaybePromise as h, type Prettify2 as i, type Partial2 as j, type SingletonBase as k, type RouteBase as l, type MetadataBase as m, type RouteSchema as n, type UnwrapRoute as o, parseCookie as p, type UnwrapGroupGuardRoute as q, type LifeCycleEvent as r, type ContentType as s, type HTTPMethod as t, type MergeSchema as u, type InlineHandler as v, type OptionalHandler as w, type MapResponse as x, type TransformHandler as y, type TraceEvent as z };

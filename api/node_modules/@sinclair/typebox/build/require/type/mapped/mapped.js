"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Mapped = exports.MappedFunctionReturnType = void 0;
const index_1 = require("../symbols/index");
const type_1 = require("../clone/type");
const index_2 = require("../discard/index");
// evaluation types
const index_3 = require("../array/index");
const index_4 = require("../async-iterator/index");
const index_5 = require("../constructor/index");
const index_6 = require("../function/index");
const index_7 = require("../indexed/index");
const index_8 = require("../intersect/index");
const index_9 = require("../iterator/index");
const index_10 = require("../literal/index");
const index_11 = require("../object/index");
const index_12 = require("../optional/index");
const index_13 = require("../promise/index");
const index_14 = require("../readonly/index");
const index_15 = require("../tuple/index");
const index_16 = require("../union/index");
// operator
const index_17 = require("../sets/index");
// mapping types
const mapped_result_1 = require("./mapped-result");
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
// prettier-ignore
const type_2 = require("../guard/type");
// prettier-ignore
function FromMappedResult(K, P) {
    return (K in P
        ? FromSchemaType(K, P[K])
        : (0, mapped_result_1.MappedResult)(P));
}
// prettier-ignore
function MappedKeyToKnownMappedResultProperties(K) {
    return { [K]: (0, index_10.Literal)(K) };
}
// prettier-ignore
function MappedKeyToUnknownMappedResultProperties(P) {
    return P.reduce((Acc, L) => {
        return { ...Acc, [L]: (0, index_10.Literal)(L) };
    }, {});
}
// prettier-ignore
function MappedKeyToMappedResultProperties(K, P) {
    return ((0, index_17.SetIncludes)(P, K)
        ? MappedKeyToKnownMappedResultProperties(K)
        : MappedKeyToUnknownMappedResultProperties(P));
}
// prettier-ignore
function FromMappedKey(K, P) {
    const R = MappedKeyToMappedResultProperties(K, P);
    return FromMappedResult(K, R);
}
// prettier-ignore
function FromRest(K, T) {
    return T.map(L => FromSchemaType(K, L));
}
// prettier-ignore
function FromProperties(K, T) {
    return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K2) => {
        return { ...Acc, [K2]: FromSchemaType(K, T[K2]) };
    }, {});
}
// prettier-ignore
function FromSchemaType(K, T) {
    return (
    // unevaluated modifier types
    (0, type_2.IsOptional)(T) ? (0, index_12.Optional)(FromSchemaType(K, (0, index_2.Discard)(T, [index_1.OptionalKind]))) :
        (0, type_2.IsReadonly)(T) ? (0, index_14.Readonly)(FromSchemaType(K, (0, index_2.Discard)(T, [index_1.ReadonlyKind]))) :
            // unevaluated mapped types
            (0, type_2.IsMappedResult)(T) ? FromMappedResult(K, T.properties) :
                (0, type_2.IsMappedKey)(T) ? FromMappedKey(K, T.keys) :
                    // unevaluated types
                    (0, type_2.IsConstructor)(T) ? (0, index_5.Constructor)(FromRest(K, T.parameters), FromSchemaType(K, T.returns)) :
                        (0, type_2.IsFunction)(T) ? (0, index_6.Function)(FromRest(K, T.parameters), FromSchemaType(K, T.returns)) :
                            (0, type_2.IsAsyncIterator)(T) ? (0, index_4.AsyncIterator)(FromSchemaType(K, T.items)) :
                                (0, type_2.IsIterator)(T) ? (0, index_9.Iterator)(FromSchemaType(K, T.items)) :
                                    (0, type_2.IsIntersect)(T) ? (0, index_8.Intersect)(FromRest(K, T.allOf)) :
                                        (0, type_2.IsUnion)(T) ? (0, index_16.Union)(FromRest(K, T.anyOf)) :
                                            (0, type_2.IsTuple)(T) ? (0, index_15.Tuple)(FromRest(K, T.items ?? [])) :
                                                (0, type_2.IsObject)(T) ? (0, index_11.Object)(FromProperties(K, T.properties)) :
                                                    (0, type_2.IsArray)(T) ? (0, index_3.Array)(FromSchemaType(K, T.items)) :
                                                        (0, type_2.IsPromise)(T) ? (0, index_13.Promise)(FromSchemaType(K, T.item)) :
                                                            T);
}
// prettier-ignore
function MappedFunctionReturnType(K, T, Acc = {}) {
    return K.reduce((Acc, L) => {
        return { ...Acc, [L]: FromSchemaType(L, T) };
    }, {});
}
exports.MappedFunctionReturnType = MappedFunctionReturnType;
/** `[Json]` Creates a Mapped object type */
function Mapped(key, map, options = {}) {
    const K = (0, type_2.IsSchema)(key) ? (0, index_7.IndexPropertyKeys)(key) : key;
    const RT = map({ [index_1.Kind]: 'MappedKey', keys: K });
    const R = MappedFunctionReturnType(K, RT);
    return (0, type_1.CloneType)((0, index_11.Object)(R), options);
}
exports.Mapped = Mapped;
